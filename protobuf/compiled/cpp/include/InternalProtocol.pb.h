// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: InternalProtocol.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_InternalProtocol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_InternalProtocol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_InternalProtocol_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_InternalProtocol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_InternalProtocol_2eproto;
namespace InternalProtocol {
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class DeviceCommand;
struct DeviceCommandDefaultTypeInternal;
extern DeviceCommandDefaultTypeInternal _DeviceCommand_default_instance_;
class DeviceConnect;
struct DeviceConnectDefaultTypeInternal;
extern DeviceConnectDefaultTypeInternal _DeviceConnect_default_instance_;
class DeviceConnectResponse;
struct DeviceConnectResponseDefaultTypeInternal;
extern DeviceConnectResponseDefaultTypeInternal _DeviceConnectResponse_default_instance_;
class DeviceStatus;
struct DeviceStatusDefaultTypeInternal;
extern DeviceStatusDefaultTypeInternal _DeviceStatus_default_instance_;
class InternalClient;
struct InternalClientDefaultTypeInternal;
extern InternalClientDefaultTypeInternal _InternalClient_default_instance_;
class InternalServer;
struct InternalServerDefaultTypeInternal;
extern InternalServerDefaultTypeInternal _InternalServer_default_instance_;
}  // namespace InternalProtocol
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace InternalProtocol {
enum DeviceConnectResponse_ResponseType : int {
  DeviceConnectResponse_ResponseType_OK = 0,
  DeviceConnectResponse_ResponseType_ALREADY_CONNECTED = 1,
  DeviceConnectResponse_ResponseType_MODULE_NOT_SUPPORTED = 2,
  DeviceConnectResponse_ResponseType_DEVICE_NOT_SUPPORTED = 3,
  DeviceConnectResponse_ResponseType_HIGHER_PRIORITY_ALREADY_CONNECTED = 4,
  DeviceConnectResponse_ResponseType_DeviceConnectResponse_ResponseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeviceConnectResponse_ResponseType_DeviceConnectResponse_ResponseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeviceConnectResponse_ResponseType_IsValid(int value);
extern const uint32_t DeviceConnectResponse_ResponseType_internal_data_[];
constexpr DeviceConnectResponse_ResponseType DeviceConnectResponse_ResponseType_ResponseType_MIN = static_cast<DeviceConnectResponse_ResponseType>(0);
constexpr DeviceConnectResponse_ResponseType DeviceConnectResponse_ResponseType_ResponseType_MAX = static_cast<DeviceConnectResponse_ResponseType>(4);
constexpr int DeviceConnectResponse_ResponseType_ResponseType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
DeviceConnectResponse_ResponseType_descriptor();
template <typename T>
const std::string& DeviceConnectResponse_ResponseType_Name(T value) {
  static_assert(std::is_same<T, DeviceConnectResponse_ResponseType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseType_Name().");
  return DeviceConnectResponse_ResponseType_Name(static_cast<DeviceConnectResponse_ResponseType>(value));
}
template <>
inline const std::string& DeviceConnectResponse_ResponseType_Name(DeviceConnectResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DeviceConnectResponse_ResponseType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DeviceConnectResponse_ResponseType_Parse(absl::string_view name, DeviceConnectResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceConnectResponse_ResponseType>(
      DeviceConnectResponse_ResponseType_descriptor(), name, value);
}
enum Device_Module : int {
  Device_Module_RESERVED_MODULE = 0,
  Device_Module_MISSION_MODULE = 1,
  Device_Module_IO_MODULE = 2,
  Device_Module_EXAMPLE_MODULE = 1000,
  Device_Module_Device_Module_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Device_Module_Device_Module_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Device_Module_IsValid(int value);
extern const uint32_t Device_Module_internal_data_[];
constexpr Device_Module Device_Module_Module_MIN = static_cast<Device_Module>(0);
constexpr Device_Module Device_Module_Module_MAX = static_cast<Device_Module>(1000);
constexpr int Device_Module_Module_ARRAYSIZE = 1000 + 1;
const ::google::protobuf::EnumDescriptor*
Device_Module_descriptor();
template <typename T>
const std::string& Device_Module_Name(T value) {
  static_assert(std::is_same<T, Device_Module>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Module_Name().");
  return ::google::protobuf::internal::NameOfEnum(Device_Module_descriptor(), value);
}
inline bool Device_Module_Parse(absl::string_view name, Device_Module* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Device_Module>(
      Device_Module_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Device final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Device(
      ::google::protobuf::internal::ConstantInitialized);

  inline Device(const Device& from) : Device(nullptr, from) {}
  inline Device(Device&& from) noexcept
      : Device(nullptr, std::move(from)) {}
  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
        &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Device& a, Device& b) { a.Swap(&b); }
  inline void Swap(Device* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Device* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Device>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Device& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Device& from) { Device::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Device* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.Device"; }

 protected:
  explicit Device(::google::protobuf::Arena* arena);
  Device(::google::protobuf::Arena* arena, const Device& from);
  Device(::google::protobuf::Arena* arena, Device&& from) noexcept
      : Device(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Module = Device_Module;
  static constexpr Module RESERVED_MODULE = Device_Module_RESERVED_MODULE;
  static constexpr Module MISSION_MODULE = Device_Module_MISSION_MODULE;
  static constexpr Module IO_MODULE = Device_Module_IO_MODULE;
  static constexpr Module EXAMPLE_MODULE = Device_Module_EXAMPLE_MODULE;
  static inline bool Module_IsValid(int value) {
    return Device_Module_IsValid(value);
  }
  static constexpr Module Module_MIN = Device_Module_Module_MIN;
  static constexpr Module Module_MAX = Device_Module_Module_MAX;
  static constexpr int Module_ARRAYSIZE = Device_Module_Module_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Module_descriptor() {
    return Device_Module_descriptor();
  }
  template <typename T>
  static inline const std::string& Module_Name(T value) {
    return Device_Module_Name(value);
  }
  static inline bool Module_Parse(absl::string_view name, Module* value) {
    return Device_Module_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceRoleFieldNumber = 3,
    kDeviceNameFieldNumber = 4,
    kModuleFieldNumber = 1,
    kDeviceTypeFieldNumber = 2,
    kPriorityFieldNumber = 5,
  };
  // string deviceRole = 3 [features = {
  void clear_devicerole() ;
  const std::string& devicerole() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_devicerole(Arg_&& arg, Args_... args);
  std::string* mutable_devicerole();
  PROTOBUF_NODISCARD std::string* release_devicerole();
  void set_allocated_devicerole(std::string* value);

  private:
  const std::string& _internal_devicerole() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicerole(
      const std::string& value);
  std::string* _internal_mutable_devicerole();

  public:
  // string deviceName = 4 [features = {
  void clear_devicename() ;
  const std::string& devicename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_devicename(Arg_&& arg, Args_... args);
  std::string* mutable_devicename();
  PROTOBUF_NODISCARD std::string* release_devicename();
  void set_allocated_devicename(std::string* value);

  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(
      const std::string& value);
  std::string* _internal_mutable_devicename();

  public:
  // .InternalProtocol.Device.Module module = 1 [features = {
  void clear_module() ;
  ::InternalProtocol::Device_Module module() const;
  void set_module(::InternalProtocol::Device_Module value);

  private:
  ::InternalProtocol::Device_Module _internal_module() const;
  void _internal_set_module(::InternalProtocol::Device_Module value);

  public:
  // uint32 deviceType = 2 [features = {
  void clear_devicetype() ;
  ::uint32_t devicetype() const;
  void set_devicetype(::uint32_t value);

  private:
  ::uint32_t _internal_devicetype() const;
  void _internal_set_devicetype(::uint32_t value);

  public:
  // uint32 priority = 5 [features = {
  void clear_priority() ;
  ::uint32_t priority() const;
  void set_priority(::uint32_t value);

  private:
  ::uint32_t _internal_priority() const;
  void _internal_set_priority(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:InternalProtocol.Device)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      52, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Device_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Device& from_msg);
    ::google::protobuf::internal::ArenaStringPtr devicerole_;
    ::google::protobuf::internal::ArenaStringPtr devicename_;
    int module_;
    ::uint32_t devicetype_;
    ::uint32_t priority_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};
// -------------------------------------------------------------------

class DeviceStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.DeviceStatus) */ {
 public:
  inline DeviceStatus() : DeviceStatus(nullptr) {}
  ~DeviceStatus() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceStatus(const DeviceStatus& from) : DeviceStatus(nullptr, from) {}
  inline DeviceStatus(DeviceStatus&& from) noexcept
      : DeviceStatus(nullptr, std::move(from)) {}
  inline DeviceStatus& operator=(const DeviceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceStatus& operator=(DeviceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceStatus* internal_default_instance() {
    return reinterpret_cast<const DeviceStatus*>(
        &_DeviceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DeviceStatus& a, DeviceStatus& b) { a.Swap(&b); }
  inline void Swap(DeviceStatus* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DeviceStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceStatus& from) { DeviceStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeviceStatus* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.DeviceStatus"; }

 protected:
  explicit DeviceStatus(::google::protobuf::Arena* arena);
  DeviceStatus(::google::protobuf::Arena* arena, const DeviceStatus& from);
  DeviceStatus(::google::protobuf::Arena* arena, DeviceStatus&& from) noexcept
      : DeviceStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusDataFieldNumber = 2,
    kDeviceFieldNumber = 1,
  };
  // bytes statusData = 2 [features = {
  void clear_statusdata() ;
  const std::string& statusdata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_statusdata(Arg_&& arg, Args_... args);
  std::string* mutable_statusdata();
  PROTOBUF_NODISCARD std::string* release_statusdata();
  void set_allocated_statusdata(std::string* value);

  private:
  const std::string& _internal_statusdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statusdata(
      const std::string& value);
  std::string* _internal_mutable_statusdata();

  public:
  // .InternalProtocol.Device device = 1;
  bool has_device() const;
  void clear_device() ;
  const ::InternalProtocol::Device& device() const;
  PROTOBUF_NODISCARD ::InternalProtocol::Device* release_device();
  ::InternalProtocol::Device* mutable_device();
  void set_allocated_device(::InternalProtocol::Device* value);
  void unsafe_arena_set_allocated_device(::InternalProtocol::Device* value);
  ::InternalProtocol::Device* unsafe_arena_release_device();

  private:
  const ::InternalProtocol::Device& _internal_device() const;
  ::InternalProtocol::Device* _internal_mutable_device();

  public:
  // @@protoc_insertion_point(class_scope:InternalProtocol.DeviceStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeviceStatus_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr statusdata_;
    ::InternalProtocol::Device* device_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};
// -------------------------------------------------------------------

class DeviceConnectResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.DeviceConnectResponse) */ {
 public:
  inline DeviceConnectResponse() : DeviceConnectResponse(nullptr) {}
  ~DeviceConnectResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceConnectResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceConnectResponse(const DeviceConnectResponse& from) : DeviceConnectResponse(nullptr, from) {}
  inline DeviceConnectResponse(DeviceConnectResponse&& from) noexcept
      : DeviceConnectResponse(nullptr, std::move(from)) {}
  inline DeviceConnectResponse& operator=(const DeviceConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceConnectResponse& operator=(DeviceConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceConnectResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceConnectResponse*>(
        &_DeviceConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DeviceConnectResponse& a, DeviceConnectResponse& b) { a.Swap(&b); }
  inline void Swap(DeviceConnectResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceConnectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceConnectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DeviceConnectResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceConnectResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceConnectResponse& from) { DeviceConnectResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeviceConnectResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.DeviceConnectResponse"; }

 protected:
  explicit DeviceConnectResponse(::google::protobuf::Arena* arena);
  DeviceConnectResponse(::google::protobuf::Arena* arena, const DeviceConnectResponse& from);
  DeviceConnectResponse(::google::protobuf::Arena* arena, DeviceConnectResponse&& from) noexcept
      : DeviceConnectResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ResponseType = DeviceConnectResponse_ResponseType;
  static constexpr ResponseType OK = DeviceConnectResponse_ResponseType_OK;
  static constexpr ResponseType ALREADY_CONNECTED = DeviceConnectResponse_ResponseType_ALREADY_CONNECTED;
  static constexpr ResponseType MODULE_NOT_SUPPORTED = DeviceConnectResponse_ResponseType_MODULE_NOT_SUPPORTED;
  static constexpr ResponseType DEVICE_NOT_SUPPORTED = DeviceConnectResponse_ResponseType_DEVICE_NOT_SUPPORTED;
  static constexpr ResponseType HIGHER_PRIORITY_ALREADY_CONNECTED = DeviceConnectResponse_ResponseType_HIGHER_PRIORITY_ALREADY_CONNECTED;
  static inline bool ResponseType_IsValid(int value) {
    return DeviceConnectResponse_ResponseType_IsValid(value);
  }
  static constexpr ResponseType ResponseType_MIN = DeviceConnectResponse_ResponseType_ResponseType_MIN;
  static constexpr ResponseType ResponseType_MAX = DeviceConnectResponse_ResponseType_ResponseType_MAX;
  static constexpr int ResponseType_ARRAYSIZE = DeviceConnectResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ResponseType_descriptor() {
    return DeviceConnectResponse_ResponseType_descriptor();
  }
  template <typename T>
  static inline const std::string& ResponseType_Name(T value) {
    return DeviceConnectResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(absl::string_view name, ResponseType* value) {
    return DeviceConnectResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 2,
    kResponseTypeFieldNumber = 1,
  };
  // .InternalProtocol.Device device = 2;
  bool has_device() const;
  void clear_device() ;
  const ::InternalProtocol::Device& device() const;
  PROTOBUF_NODISCARD ::InternalProtocol::Device* release_device();
  ::InternalProtocol::Device* mutable_device();
  void set_allocated_device(::InternalProtocol::Device* value);
  void unsafe_arena_set_allocated_device(::InternalProtocol::Device* value);
  ::InternalProtocol::Device* unsafe_arena_release_device();

  private:
  const ::InternalProtocol::Device& _internal_device() const;
  ::InternalProtocol::Device* _internal_mutable_device();

  public:
  // .InternalProtocol.DeviceConnectResponse.ResponseType responseType = 1 [features = {
  void clear_responsetype() ;
  ::InternalProtocol::DeviceConnectResponse_ResponseType responsetype() const;
  void set_responsetype(::InternalProtocol::DeviceConnectResponse_ResponseType value);

  private:
  ::InternalProtocol::DeviceConnectResponse_ResponseType _internal_responsetype() const;
  void _internal_set_responsetype(::InternalProtocol::DeviceConnectResponse_ResponseType value);

  public:
  // @@protoc_insertion_point(class_scope:InternalProtocol.DeviceConnectResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeviceConnectResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceConnectResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::InternalProtocol::Device* device_;
    int responsetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};
// -------------------------------------------------------------------

class DeviceConnect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.DeviceConnect) */ {
 public:
  inline DeviceConnect() : DeviceConnect(nullptr) {}
  ~DeviceConnect() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceConnect(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceConnect(const DeviceConnect& from) : DeviceConnect(nullptr, from) {}
  inline DeviceConnect(DeviceConnect&& from) noexcept
      : DeviceConnect(nullptr, std::move(from)) {}
  inline DeviceConnect& operator=(const DeviceConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceConnect& operator=(DeviceConnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceConnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceConnect* internal_default_instance() {
    return reinterpret_cast<const DeviceConnect*>(
        &_DeviceConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DeviceConnect& a, DeviceConnect& b) { a.Swap(&b); }
  inline void Swap(DeviceConnect* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceConnect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceConnect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DeviceConnect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceConnect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceConnect& from) { DeviceConnect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeviceConnect* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.DeviceConnect"; }

 protected:
  explicit DeviceConnect(::google::protobuf::Arena* arena);
  DeviceConnect(::google::protobuf::Arena* arena, const DeviceConnect& from);
  DeviceConnect(::google::protobuf::Arena* arena, DeviceConnect&& from) noexcept
      : DeviceConnect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
  };
  // .InternalProtocol.Device device = 1;
  bool has_device() const;
  void clear_device() ;
  const ::InternalProtocol::Device& device() const;
  PROTOBUF_NODISCARD ::InternalProtocol::Device* release_device();
  ::InternalProtocol::Device* mutable_device();
  void set_allocated_device(::InternalProtocol::Device* value);
  void unsafe_arena_set_allocated_device(::InternalProtocol::Device* value);
  ::InternalProtocol::Device* unsafe_arena_release_device();

  private:
  const ::InternalProtocol::Device& _internal_device() const;
  ::InternalProtocol::Device* _internal_mutable_device();

  public:
  // @@protoc_insertion_point(class_scope:InternalProtocol.DeviceConnect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeviceConnect_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceConnect& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::InternalProtocol::Device* device_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};
// -------------------------------------------------------------------

class DeviceCommand final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.DeviceCommand) */ {
 public:
  inline DeviceCommand() : DeviceCommand(nullptr) {}
  ~DeviceCommand() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceCommand(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceCommand(const DeviceCommand& from) : DeviceCommand(nullptr, from) {}
  inline DeviceCommand(DeviceCommand&& from) noexcept
      : DeviceCommand(nullptr, std::move(from)) {}
  inline DeviceCommand& operator=(const DeviceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceCommand& operator=(DeviceCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceCommand* internal_default_instance() {
    return reinterpret_cast<const DeviceCommand*>(
        &_DeviceCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(DeviceCommand& a, DeviceCommand& b) { a.Swap(&b); }
  inline void Swap(DeviceCommand* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceCommand* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceCommand* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DeviceCommand>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceCommand& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceCommand& from) { DeviceCommand::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeviceCommand* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.DeviceCommand"; }

 protected:
  explicit DeviceCommand(::google::protobuf::Arena* arena);
  DeviceCommand(::google::protobuf::Arena* arena, const DeviceCommand& from);
  DeviceCommand(::google::protobuf::Arena* arena, DeviceCommand&& from) noexcept
      : DeviceCommand(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommandDataFieldNumber = 2,
    kDeviceFieldNumber = 1,
  };
  // bytes commandData = 2 [features = {
  void clear_commanddata() ;
  const std::string& commanddata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commanddata(Arg_&& arg, Args_... args);
  std::string* mutable_commanddata();
  PROTOBUF_NODISCARD std::string* release_commanddata();
  void set_allocated_commanddata(std::string* value);

  private:
  const std::string& _internal_commanddata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commanddata(
      const std::string& value);
  std::string* _internal_mutable_commanddata();

  public:
  // .InternalProtocol.Device device = 1;
  bool has_device() const;
  void clear_device() ;
  const ::InternalProtocol::Device& device() const;
  PROTOBUF_NODISCARD ::InternalProtocol::Device* release_device();
  ::InternalProtocol::Device* mutable_device();
  void set_allocated_device(::InternalProtocol::Device* value);
  void unsafe_arena_set_allocated_device(::InternalProtocol::Device* value);
  ::InternalProtocol::Device* unsafe_arena_release_device();

  private:
  const ::InternalProtocol::Device& _internal_device() const;
  ::InternalProtocol::Device* _internal_mutable_device();

  public:
  // @@protoc_insertion_point(class_scope:InternalProtocol.DeviceCommand)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeviceCommand_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceCommand& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr commanddata_;
    ::InternalProtocol::Device* device_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};
// -------------------------------------------------------------------

class InternalServer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.InternalServer) */ {
 public:
  inline InternalServer() : InternalServer(nullptr) {}
  ~InternalServer() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InternalServer(
      ::google::protobuf::internal::ConstantInitialized);

  inline InternalServer(const InternalServer& from) : InternalServer(nullptr, from) {}
  inline InternalServer(InternalServer&& from) noexcept
      : InternalServer(nullptr, std::move(from)) {}
  inline InternalServer& operator=(const InternalServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalServer& operator=(InternalServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalServer& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kDeviceConnectResponse = 1,
    kDeviceCommand = 2,
    MESSAGETYPE_NOT_SET = 0,
  };
  static inline const InternalServer* internal_default_instance() {
    return reinterpret_cast<const InternalServer*>(
        &_InternalServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(InternalServer& a, InternalServer& b) { a.Swap(&b); }
  inline void Swap(InternalServer* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalServer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalServer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InternalServer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InternalServer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InternalServer& from) { InternalServer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InternalServer* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.InternalServer"; }

 protected:
  explicit InternalServer(::google::protobuf::Arena* arena);
  InternalServer(::google::protobuf::Arena* arena, const InternalServer& from);
  InternalServer(::google::protobuf::Arena* arena, InternalServer&& from) noexcept
      : InternalServer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceConnectResponseFieldNumber = 1,
    kDeviceCommandFieldNumber = 2,
  };
  // .InternalProtocol.DeviceConnectResponse deviceConnectResponse = 1;
  bool has_deviceconnectresponse() const;
  private:
  bool _internal_has_deviceconnectresponse() const;

  public:
  void clear_deviceconnectresponse() ;
  const ::InternalProtocol::DeviceConnectResponse& deviceconnectresponse() const;
  PROTOBUF_NODISCARD ::InternalProtocol::DeviceConnectResponse* release_deviceconnectresponse();
  ::InternalProtocol::DeviceConnectResponse* mutable_deviceconnectresponse();
  void set_allocated_deviceconnectresponse(::InternalProtocol::DeviceConnectResponse* value);
  void unsafe_arena_set_allocated_deviceconnectresponse(::InternalProtocol::DeviceConnectResponse* value);
  ::InternalProtocol::DeviceConnectResponse* unsafe_arena_release_deviceconnectresponse();

  private:
  const ::InternalProtocol::DeviceConnectResponse& _internal_deviceconnectresponse() const;
  ::InternalProtocol::DeviceConnectResponse* _internal_mutable_deviceconnectresponse();

  public:
  // .InternalProtocol.DeviceCommand deviceCommand = 2;
  bool has_devicecommand() const;
  private:
  bool _internal_has_devicecommand() const;

  public:
  void clear_devicecommand() ;
  const ::InternalProtocol::DeviceCommand& devicecommand() const;
  PROTOBUF_NODISCARD ::InternalProtocol::DeviceCommand* release_devicecommand();
  ::InternalProtocol::DeviceCommand* mutable_devicecommand();
  void set_allocated_devicecommand(::InternalProtocol::DeviceCommand* value);
  void unsafe_arena_set_allocated_devicecommand(::InternalProtocol::DeviceCommand* value);
  ::InternalProtocol::DeviceCommand* unsafe_arena_release_devicecommand();

  private:
  const ::InternalProtocol::DeviceCommand& _internal_devicecommand() const;
  ::InternalProtocol::DeviceCommand* _internal_mutable_devicecommand();

  public:
  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:InternalProtocol.InternalServer)
 private:
  class _Internal;
  void set_has_deviceconnectresponse();
  void set_has_devicecommand();
  inline bool has_MessageType() const;
  inline void clear_has_MessageType();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InternalServer_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InternalServer& from_msg);
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::InternalProtocol::DeviceConnectResponse* deviceconnectresponse_;
      ::InternalProtocol::DeviceCommand* devicecommand_;
    } MessageType_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};
// -------------------------------------------------------------------

class InternalClient final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:InternalProtocol.InternalClient) */ {
 public:
  inline InternalClient() : InternalClient(nullptr) {}
  ~InternalClient() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InternalClient(
      ::google::protobuf::internal::ConstantInitialized);

  inline InternalClient(const InternalClient& from) : InternalClient(nullptr, from) {}
  inline InternalClient(InternalClient&& from) noexcept
      : InternalClient(nullptr, std::move(from)) {}
  inline InternalClient& operator=(const InternalClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalClient& operator=(InternalClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalClient& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kDeviceConnect = 1,
    kDeviceStatus = 2,
    MESSAGETYPE_NOT_SET = 0,
  };
  static inline const InternalClient* internal_default_instance() {
    return reinterpret_cast<const InternalClient*>(
        &_InternalClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(InternalClient& a, InternalClient& b) { a.Swap(&b); }
  inline void Swap(InternalClient* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalClient* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalClient* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InternalClient>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InternalClient& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InternalClient& from) { InternalClient::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InternalClient* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "InternalProtocol.InternalClient"; }

 protected:
  explicit InternalClient(::google::protobuf::Arena* arena);
  InternalClient(::google::protobuf::Arena* arena, const InternalClient& from);
  InternalClient(::google::protobuf::Arena* arena, InternalClient&& from) noexcept
      : InternalClient(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceConnectFieldNumber = 1,
    kDeviceStatusFieldNumber = 2,
  };
  // .InternalProtocol.DeviceConnect deviceConnect = 1;
  bool has_deviceconnect() const;
  private:
  bool _internal_has_deviceconnect() const;

  public:
  void clear_deviceconnect() ;
  const ::InternalProtocol::DeviceConnect& deviceconnect() const;
  PROTOBUF_NODISCARD ::InternalProtocol::DeviceConnect* release_deviceconnect();
  ::InternalProtocol::DeviceConnect* mutable_deviceconnect();
  void set_allocated_deviceconnect(::InternalProtocol::DeviceConnect* value);
  void unsafe_arena_set_allocated_deviceconnect(::InternalProtocol::DeviceConnect* value);
  ::InternalProtocol::DeviceConnect* unsafe_arena_release_deviceconnect();

  private:
  const ::InternalProtocol::DeviceConnect& _internal_deviceconnect() const;
  ::InternalProtocol::DeviceConnect* _internal_mutable_deviceconnect();

  public:
  // .InternalProtocol.DeviceStatus deviceStatus = 2;
  bool has_devicestatus() const;
  private:
  bool _internal_has_devicestatus() const;

  public:
  void clear_devicestatus() ;
  const ::InternalProtocol::DeviceStatus& devicestatus() const;
  PROTOBUF_NODISCARD ::InternalProtocol::DeviceStatus* release_devicestatus();
  ::InternalProtocol::DeviceStatus* mutable_devicestatus();
  void set_allocated_devicestatus(::InternalProtocol::DeviceStatus* value);
  void unsafe_arena_set_allocated_devicestatus(::InternalProtocol::DeviceStatus* value);
  ::InternalProtocol::DeviceStatus* unsafe_arena_release_devicestatus();

  private:
  const ::InternalProtocol::DeviceStatus& _internal_devicestatus() const;
  ::InternalProtocol::DeviceStatus* _internal_mutable_devicestatus();

  public:
  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:InternalProtocol.InternalClient)
 private:
  class _Internal;
  void set_has_deviceconnect();
  void set_has_devicestatus();
  inline bool has_MessageType() const;
  inline void clear_has_MessageType();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InternalClient_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InternalClient& from_msg);
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::InternalProtocol::DeviceConnect* deviceconnect_;
      ::InternalProtocol::DeviceStatus* devicestatus_;
    } MessageType_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_InternalProtocol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InternalClient

// .InternalProtocol.DeviceConnect deviceConnect = 1;
inline bool InternalClient::has_deviceconnect() const {
  return MessageType_case() == kDeviceConnect;
}
inline bool InternalClient::_internal_has_deviceconnect() const {
  return MessageType_case() == kDeviceConnect;
}
inline void InternalClient::set_has_deviceconnect() {
  _impl_._oneof_case_[0] = kDeviceConnect;
}
inline void InternalClient::clear_deviceconnect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (MessageType_case() == kDeviceConnect) {
    if (GetArena() == nullptr) {
      delete _impl_.MessageType_.deviceconnect_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.MessageType_.deviceconnect_);
    }
    clear_has_MessageType();
  }
}
inline ::InternalProtocol::DeviceConnect* InternalClient::release_deviceconnect() {
  // @@protoc_insertion_point(field_release:InternalProtocol.InternalClient.deviceConnect)
  if (MessageType_case() == kDeviceConnect) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.deviceconnect_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.deviceconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InternalProtocol::DeviceConnect& InternalClient::_internal_deviceconnect() const {
  return MessageType_case() == kDeviceConnect ? *_impl_.MessageType_.deviceconnect_ : reinterpret_cast<::InternalProtocol::DeviceConnect&>(::InternalProtocol::_DeviceConnect_default_instance_);
}
inline const ::InternalProtocol::DeviceConnect& InternalClient::deviceconnect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.InternalClient.deviceConnect)
  return _internal_deviceconnect();
}
inline ::InternalProtocol::DeviceConnect* InternalClient::unsafe_arena_release_deviceconnect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InternalProtocol.InternalClient.deviceConnect)
  if (MessageType_case() == kDeviceConnect) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.deviceconnect_;
    _impl_.MessageType_.deviceconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InternalClient::unsafe_arena_set_allocated_deviceconnect(::InternalProtocol::DeviceConnect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_MessageType();
  if (value) {
    set_has_deviceconnect();
    _impl_.MessageType_.deviceconnect_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.InternalClient.deviceConnect)
}
inline ::InternalProtocol::DeviceConnect* InternalClient::_internal_mutable_deviceconnect() {
  if (MessageType_case() != kDeviceConnect) {
    clear_MessageType();
    set_has_deviceconnect();
    _impl_.MessageType_.deviceconnect_ =
        ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::DeviceConnect>(GetArena());
  }
  return _impl_.MessageType_.deviceconnect_;
}
inline ::InternalProtocol::DeviceConnect* InternalClient::mutable_deviceconnect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::InternalProtocol::DeviceConnect* _msg = _internal_mutable_deviceconnect();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.InternalClient.deviceConnect)
  return _msg;
}

// .InternalProtocol.DeviceStatus deviceStatus = 2;
inline bool InternalClient::has_devicestatus() const {
  return MessageType_case() == kDeviceStatus;
}
inline bool InternalClient::_internal_has_devicestatus() const {
  return MessageType_case() == kDeviceStatus;
}
inline void InternalClient::set_has_devicestatus() {
  _impl_._oneof_case_[0] = kDeviceStatus;
}
inline void InternalClient::clear_devicestatus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (MessageType_case() == kDeviceStatus) {
    if (GetArena() == nullptr) {
      delete _impl_.MessageType_.devicestatus_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.MessageType_.devicestatus_);
    }
    clear_has_MessageType();
  }
}
inline ::InternalProtocol::DeviceStatus* InternalClient::release_devicestatus() {
  // @@protoc_insertion_point(field_release:InternalProtocol.InternalClient.deviceStatus)
  if (MessageType_case() == kDeviceStatus) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.devicestatus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.devicestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InternalProtocol::DeviceStatus& InternalClient::_internal_devicestatus() const {
  return MessageType_case() == kDeviceStatus ? *_impl_.MessageType_.devicestatus_ : reinterpret_cast<::InternalProtocol::DeviceStatus&>(::InternalProtocol::_DeviceStatus_default_instance_);
}
inline const ::InternalProtocol::DeviceStatus& InternalClient::devicestatus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.InternalClient.deviceStatus)
  return _internal_devicestatus();
}
inline ::InternalProtocol::DeviceStatus* InternalClient::unsafe_arena_release_devicestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InternalProtocol.InternalClient.deviceStatus)
  if (MessageType_case() == kDeviceStatus) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.devicestatus_;
    _impl_.MessageType_.devicestatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InternalClient::unsafe_arena_set_allocated_devicestatus(::InternalProtocol::DeviceStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_MessageType();
  if (value) {
    set_has_devicestatus();
    _impl_.MessageType_.devicestatus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.InternalClient.deviceStatus)
}
inline ::InternalProtocol::DeviceStatus* InternalClient::_internal_mutable_devicestatus() {
  if (MessageType_case() != kDeviceStatus) {
    clear_MessageType();
    set_has_devicestatus();
    _impl_.MessageType_.devicestatus_ =
        ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::DeviceStatus>(GetArena());
  }
  return _impl_.MessageType_.devicestatus_;
}
inline ::InternalProtocol::DeviceStatus* InternalClient::mutable_devicestatus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::InternalProtocol::DeviceStatus* _msg = _internal_mutable_devicestatus();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.InternalClient.deviceStatus)
  return _msg;
}

inline bool InternalClient::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void InternalClient::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline InternalClient::MessageTypeCase InternalClient::MessageType_case() const {
  return InternalClient::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalServer

// .InternalProtocol.DeviceConnectResponse deviceConnectResponse = 1;
inline bool InternalServer::has_deviceconnectresponse() const {
  return MessageType_case() == kDeviceConnectResponse;
}
inline bool InternalServer::_internal_has_deviceconnectresponse() const {
  return MessageType_case() == kDeviceConnectResponse;
}
inline void InternalServer::set_has_deviceconnectresponse() {
  _impl_._oneof_case_[0] = kDeviceConnectResponse;
}
inline void InternalServer::clear_deviceconnectresponse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (MessageType_case() == kDeviceConnectResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.MessageType_.deviceconnectresponse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.MessageType_.deviceconnectresponse_);
    }
    clear_has_MessageType();
  }
}
inline ::InternalProtocol::DeviceConnectResponse* InternalServer::release_deviceconnectresponse() {
  // @@protoc_insertion_point(field_release:InternalProtocol.InternalServer.deviceConnectResponse)
  if (MessageType_case() == kDeviceConnectResponse) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.deviceconnectresponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.deviceconnectresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InternalProtocol::DeviceConnectResponse& InternalServer::_internal_deviceconnectresponse() const {
  return MessageType_case() == kDeviceConnectResponse ? *_impl_.MessageType_.deviceconnectresponse_ : reinterpret_cast<::InternalProtocol::DeviceConnectResponse&>(::InternalProtocol::_DeviceConnectResponse_default_instance_);
}
inline const ::InternalProtocol::DeviceConnectResponse& InternalServer::deviceconnectresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.InternalServer.deviceConnectResponse)
  return _internal_deviceconnectresponse();
}
inline ::InternalProtocol::DeviceConnectResponse* InternalServer::unsafe_arena_release_deviceconnectresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InternalProtocol.InternalServer.deviceConnectResponse)
  if (MessageType_case() == kDeviceConnectResponse) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.deviceconnectresponse_;
    _impl_.MessageType_.deviceconnectresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InternalServer::unsafe_arena_set_allocated_deviceconnectresponse(::InternalProtocol::DeviceConnectResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_MessageType();
  if (value) {
    set_has_deviceconnectresponse();
    _impl_.MessageType_.deviceconnectresponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.InternalServer.deviceConnectResponse)
}
inline ::InternalProtocol::DeviceConnectResponse* InternalServer::_internal_mutable_deviceconnectresponse() {
  if (MessageType_case() != kDeviceConnectResponse) {
    clear_MessageType();
    set_has_deviceconnectresponse();
    _impl_.MessageType_.deviceconnectresponse_ =
        ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::DeviceConnectResponse>(GetArena());
  }
  return _impl_.MessageType_.deviceconnectresponse_;
}
inline ::InternalProtocol::DeviceConnectResponse* InternalServer::mutable_deviceconnectresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::InternalProtocol::DeviceConnectResponse* _msg = _internal_mutable_deviceconnectresponse();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.InternalServer.deviceConnectResponse)
  return _msg;
}

// .InternalProtocol.DeviceCommand deviceCommand = 2;
inline bool InternalServer::has_devicecommand() const {
  return MessageType_case() == kDeviceCommand;
}
inline bool InternalServer::_internal_has_devicecommand() const {
  return MessageType_case() == kDeviceCommand;
}
inline void InternalServer::set_has_devicecommand() {
  _impl_._oneof_case_[0] = kDeviceCommand;
}
inline void InternalServer::clear_devicecommand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (MessageType_case() == kDeviceCommand) {
    if (GetArena() == nullptr) {
      delete _impl_.MessageType_.devicecommand_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.MessageType_.devicecommand_);
    }
    clear_has_MessageType();
  }
}
inline ::InternalProtocol::DeviceCommand* InternalServer::release_devicecommand() {
  // @@protoc_insertion_point(field_release:InternalProtocol.InternalServer.deviceCommand)
  if (MessageType_case() == kDeviceCommand) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.devicecommand_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.devicecommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InternalProtocol::DeviceCommand& InternalServer::_internal_devicecommand() const {
  return MessageType_case() == kDeviceCommand ? *_impl_.MessageType_.devicecommand_ : reinterpret_cast<::InternalProtocol::DeviceCommand&>(::InternalProtocol::_DeviceCommand_default_instance_);
}
inline const ::InternalProtocol::DeviceCommand& InternalServer::devicecommand() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.InternalServer.deviceCommand)
  return _internal_devicecommand();
}
inline ::InternalProtocol::DeviceCommand* InternalServer::unsafe_arena_release_devicecommand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InternalProtocol.InternalServer.deviceCommand)
  if (MessageType_case() == kDeviceCommand) {
    clear_has_MessageType();
    auto* temp = _impl_.MessageType_.devicecommand_;
    _impl_.MessageType_.devicecommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InternalServer::unsafe_arena_set_allocated_devicecommand(::InternalProtocol::DeviceCommand* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_MessageType();
  if (value) {
    set_has_devicecommand();
    _impl_.MessageType_.devicecommand_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.InternalServer.deviceCommand)
}
inline ::InternalProtocol::DeviceCommand* InternalServer::_internal_mutable_devicecommand() {
  if (MessageType_case() != kDeviceCommand) {
    clear_MessageType();
    set_has_devicecommand();
    _impl_.MessageType_.devicecommand_ =
        ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::DeviceCommand>(GetArena());
  }
  return _impl_.MessageType_.devicecommand_;
}
inline ::InternalProtocol::DeviceCommand* InternalServer::mutable_devicecommand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::InternalProtocol::DeviceCommand* _msg = _internal_mutable_devicecommand();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.InternalServer.deviceCommand)
  return _msg;
}

inline bool InternalServer::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void InternalServer::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline InternalServer::MessageTypeCase InternalServer::MessageType_case() const {
  return InternalServer::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DeviceConnect

// .InternalProtocol.Device device = 1;
inline bool DeviceConnect::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void DeviceConnect::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::InternalProtocol::Device& DeviceConnect::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::InternalProtocol::Device* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::InternalProtocol::Device&>(::InternalProtocol::_Device_default_instance_);
}
inline const ::InternalProtocol::Device& DeviceConnect::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceConnect.device)
  return _internal_device();
}
inline void DeviceConnect::unsafe_arena_set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.DeviceConnect.device)
}
inline ::InternalProtocol::Device* DeviceConnect::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::InternalProtocol::Device* DeviceConnect::unsafe_arena_release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.DeviceConnect.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::InternalProtocol::Device* DeviceConnect::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::Device>(GetArena());
    _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(p);
  }
  return _impl_.device_;
}
inline ::InternalProtocol::Device* DeviceConnect::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::InternalProtocol::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.DeviceConnect.device)
  return _msg;
}
inline void DeviceConnect::set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.DeviceConnect.device)
}

// -------------------------------------------------------------------

// DeviceConnectResponse

// .InternalProtocol.DeviceConnectResponse.ResponseType responseType = 1 [features = {
inline void DeviceConnectResponse::clear_responsetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsetype_ = 0;
}
inline ::InternalProtocol::DeviceConnectResponse_ResponseType DeviceConnectResponse::responsetype() const {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceConnectResponse.responseType)
  return _internal_responsetype();
}
inline void DeviceConnectResponse::set_responsetype(::InternalProtocol::DeviceConnectResponse_ResponseType value) {
  _internal_set_responsetype(value);
  // @@protoc_insertion_point(field_set:InternalProtocol.DeviceConnectResponse.responseType)
}
inline ::InternalProtocol::DeviceConnectResponse_ResponseType DeviceConnectResponse::_internal_responsetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::InternalProtocol::DeviceConnectResponse_ResponseType>(_impl_.responsetype_);
}
inline void DeviceConnectResponse::_internal_set_responsetype(::InternalProtocol::DeviceConnectResponse_ResponseType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsetype_ = value;
}

// .InternalProtocol.Device device = 2;
inline bool DeviceConnectResponse::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void DeviceConnectResponse::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::InternalProtocol::Device& DeviceConnectResponse::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::InternalProtocol::Device* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::InternalProtocol::Device&>(::InternalProtocol::_Device_default_instance_);
}
inline const ::InternalProtocol::Device& DeviceConnectResponse::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceConnectResponse.device)
  return _internal_device();
}
inline void DeviceConnectResponse::unsafe_arena_set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.DeviceConnectResponse.device)
}
inline ::InternalProtocol::Device* DeviceConnectResponse::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::InternalProtocol::Device* DeviceConnectResponse::unsafe_arena_release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.DeviceConnectResponse.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::InternalProtocol::Device* DeviceConnectResponse::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::Device>(GetArena());
    _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(p);
  }
  return _impl_.device_;
}
inline ::InternalProtocol::Device* DeviceConnectResponse::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::InternalProtocol::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.DeviceConnectResponse.device)
  return _msg;
}
inline void DeviceConnectResponse::set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.DeviceConnectResponse.device)
}

// -------------------------------------------------------------------

// DeviceStatus

// .InternalProtocol.Device device = 1;
inline bool DeviceStatus::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void DeviceStatus::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::InternalProtocol::Device& DeviceStatus::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::InternalProtocol::Device* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::InternalProtocol::Device&>(::InternalProtocol::_Device_default_instance_);
}
inline const ::InternalProtocol::Device& DeviceStatus::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceStatus.device)
  return _internal_device();
}
inline void DeviceStatus::unsafe_arena_set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.DeviceStatus.device)
}
inline ::InternalProtocol::Device* DeviceStatus::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::InternalProtocol::Device* DeviceStatus::unsafe_arena_release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.DeviceStatus.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::InternalProtocol::Device* DeviceStatus::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::Device>(GetArena());
    _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(p);
  }
  return _impl_.device_;
}
inline ::InternalProtocol::Device* DeviceStatus::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::InternalProtocol::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.DeviceStatus.device)
  return _msg;
}
inline void DeviceStatus::set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.DeviceStatus.device)
}

// bytes statusData = 2 [features = {
inline void DeviceStatus::clear_statusdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statusdata_.ClearToEmpty();
}
inline const std::string& DeviceStatus::statusdata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceStatus.statusData)
  return _internal_statusdata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceStatus::set_statusdata(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statusdata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InternalProtocol.DeviceStatus.statusData)
}
inline std::string* DeviceStatus::mutable_statusdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_statusdata();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.DeviceStatus.statusData)
  return _s;
}
inline const std::string& DeviceStatus::_internal_statusdata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.statusdata_.Get();
}
inline void DeviceStatus::_internal_set_statusdata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statusdata_.Set(value, GetArena());
}
inline std::string* DeviceStatus::_internal_mutable_statusdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.statusdata_.Mutable( GetArena());
}
inline std::string* DeviceStatus::release_statusdata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.DeviceStatus.statusData)
  return _impl_.statusdata_.Release();
}
inline void DeviceStatus::set_allocated_statusdata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statusdata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.statusdata_.IsDefault()) {
          _impl_.statusdata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.DeviceStatus.statusData)
}

// -------------------------------------------------------------------

// DeviceCommand

// .InternalProtocol.Device device = 1;
inline bool DeviceCommand::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void DeviceCommand::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::InternalProtocol::Device& DeviceCommand::_internal_device() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::InternalProtocol::Device* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::InternalProtocol::Device&>(::InternalProtocol::_Device_default_instance_);
}
inline const ::InternalProtocol::Device& DeviceCommand::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceCommand.device)
  return _internal_device();
}
inline void DeviceCommand::unsafe_arena_set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InternalProtocol.DeviceCommand.device)
}
inline ::InternalProtocol::Device* DeviceCommand::release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::InternalProtocol::Device* DeviceCommand::unsafe_arena_release_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.DeviceCommand.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::InternalProtocol::Device* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::InternalProtocol::Device* DeviceCommand::_internal_mutable_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::InternalProtocol::Device>(GetArena());
    _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(p);
  }
  return _impl_.device_;
}
inline ::InternalProtocol::Device* DeviceCommand::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::InternalProtocol::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.DeviceCommand.device)
  return _msg;
}
inline void DeviceCommand::set_allocated_device(::InternalProtocol::Device* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::InternalProtocol::Device*>(value);
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.DeviceCommand.device)
}

// bytes commandData = 2 [features = {
inline void DeviceCommand::clear_commanddata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commanddata_.ClearToEmpty();
}
inline const std::string& DeviceCommand::commanddata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.DeviceCommand.commandData)
  return _internal_commanddata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeviceCommand::set_commanddata(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commanddata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InternalProtocol.DeviceCommand.commandData)
}
inline std::string* DeviceCommand::mutable_commanddata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_commanddata();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.DeviceCommand.commandData)
  return _s;
}
inline const std::string& DeviceCommand::_internal_commanddata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.commanddata_.Get();
}
inline void DeviceCommand::_internal_set_commanddata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commanddata_.Set(value, GetArena());
}
inline std::string* DeviceCommand::_internal_mutable_commanddata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.commanddata_.Mutable( GetArena());
}
inline std::string* DeviceCommand::release_commanddata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.DeviceCommand.commandData)
  return _impl_.commanddata_.Release();
}
inline void DeviceCommand::set_allocated_commanddata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commanddata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commanddata_.IsDefault()) {
          _impl_.commanddata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.DeviceCommand.commandData)
}

// -------------------------------------------------------------------

// Device

// .InternalProtocol.Device.Module module = 1 [features = {
inline void Device::clear_module() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_ = 0;
}
inline ::InternalProtocol::Device_Module Device::module() const {
  // @@protoc_insertion_point(field_get:InternalProtocol.Device.module)
  return _internal_module();
}
inline void Device::set_module(::InternalProtocol::Device_Module value) {
  _internal_set_module(value);
  // @@protoc_insertion_point(field_set:InternalProtocol.Device.module)
}
inline ::InternalProtocol::Device_Module Device::_internal_module() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::InternalProtocol::Device_Module>(_impl_.module_);
}
inline void Device::_internal_set_module(::InternalProtocol::Device_Module value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.module_ = value;
}

// uint32 deviceType = 2 [features = {
inline void Device::clear_devicetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicetype_ = 0u;
}
inline ::uint32_t Device::devicetype() const {
  // @@protoc_insertion_point(field_get:InternalProtocol.Device.deviceType)
  return _internal_devicetype();
}
inline void Device::set_devicetype(::uint32_t value) {
  _internal_set_devicetype(value);
  // @@protoc_insertion_point(field_set:InternalProtocol.Device.deviceType)
}
inline ::uint32_t Device::_internal_devicetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.devicetype_;
}
inline void Device::_internal_set_devicetype(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicetype_ = value;
}

// string deviceRole = 3 [features = {
inline void Device::clear_devicerole() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicerole_.ClearToEmpty();
}
inline const std::string& Device::devicerole() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.Device.deviceRole)
  return _internal_devicerole();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Device::set_devicerole(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicerole_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InternalProtocol.Device.deviceRole)
}
inline std::string* Device::mutable_devicerole() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_devicerole();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.Device.deviceRole)
  return _s;
}
inline const std::string& Device::_internal_devicerole() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.devicerole_.Get();
}
inline void Device::_internal_set_devicerole(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicerole_.Set(value, GetArena());
}
inline std::string* Device::_internal_mutable_devicerole() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.devicerole_.Mutable( GetArena());
}
inline std::string* Device::release_devicerole() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.Device.deviceRole)
  return _impl_.devicerole_.Release();
}
inline void Device::set_allocated_devicerole(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicerole_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.devicerole_.IsDefault()) {
          _impl_.devicerole_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.Device.deviceRole)
}

// string deviceName = 4 [features = {
inline void Device::clear_devicename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicename_.ClearToEmpty();
}
inline const std::string& Device::devicename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InternalProtocol.Device.deviceName)
  return _internal_devicename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Device::set_devicename(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InternalProtocol.Device.deviceName)
}
inline std::string* Device::mutable_devicename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:InternalProtocol.Device.deviceName)
  return _s;
}
inline const std::string& Device::_internal_devicename() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.devicename_.Get();
}
inline void Device::_internal_set_devicename(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicename_.Set(value, GetArena());
}
inline std::string* Device::_internal_mutable_devicename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.devicename_.Mutable( GetArena());
}
inline std::string* Device::release_devicename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:InternalProtocol.Device.deviceName)
  return _impl_.devicename_.Release();
}
inline void Device::set_allocated_devicename(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.devicename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.devicename_.IsDefault()) {
          _impl_.devicename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InternalProtocol.Device.deviceName)
}

// uint32 priority = 5 [features = {
inline void Device::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0u;
}
inline ::uint32_t Device::priority() const {
  // @@protoc_insertion_point(field_get:InternalProtocol.Device.priority)
  return _internal_priority();
}
inline void Device::set_priority(::uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:InternalProtocol.Device.priority)
}
inline ::uint32_t Device::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void Device::_internal_set_priority(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace InternalProtocol


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::InternalProtocol::DeviceConnectResponse_ResponseType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::InternalProtocol::DeviceConnectResponse_ResponseType>() {
  return ::InternalProtocol::DeviceConnectResponse_ResponseType_descriptor();
}
template <>
struct is_proto_enum<::InternalProtocol::Device_Module> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::InternalProtocol::Device_Module>() {
  return ::InternalProtocol::Device_Module_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_InternalProtocol_2eproto_2epb_2eh
