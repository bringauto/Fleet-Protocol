// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/MissionModule.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "modules/MissionModule.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AutonomyStatus);
GPBObjCClassDeclaration(AutonomyStatus_Telemetry);
GPBObjCClassDeclaration(Position);
GPBObjCClassDeclaration(Station);

#pragma mark - MissionModuleRoot

@implementation MissionModuleRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MissionModuleRoot_FileDescriptor

static GPBFileDescriptor *MissionModuleRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"MissionModule"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AutonomyStatus

@implementation AutonomyStatus

@dynamic hasTelemetry, telemetry;
@dynamic state;
@dynamic hasNextStop, nextStop;

typedef struct AutonomyStatus__storage_ {
  uint32_t _has_storage_[1];
  AutonomyStatus_State state;
  AutonomyStatus_Telemetry *telemetry;
  Station *nextStop;
} AutonomyStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "telemetry",
        .dataTypeSpecific.clazz = GPBObjCClass(AutonomyStatus_Telemetry),
        .number = AutonomyStatus_FieldNumber_Telemetry,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutonomyStatus__storage_, telemetry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = AutonomyStatus_State_EnumDescriptor,
        .number = AutonomyStatus_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutonomyStatus__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "nextStop",
        .dataTypeSpecific.clazz = GPBObjCClass(Station),
        .number = AutonomyStatus_FieldNumber_NextStop,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AutonomyStatus__storage_, nextStop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutonomyStatus class]
                                     rootClass:[MissionModuleRoot class]
                                          file:MissionModuleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutonomyStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AutonomyStatus_State_RawValue(AutonomyStatus *message) {
  GPBDescriptor *descriptor = [AutonomyStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutonomyStatus_FieldNumber_State];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAutonomyStatus_State_RawValue(AutonomyStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [AutonomyStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutonomyStatus_FieldNumber_State];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum AutonomyStatus_State

GPBEnumDescriptor *AutonomyStatus_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Idle\000Drive\000InStop\000Obstacle\000Error\000";
    static const int32_t values[] = {
        AutonomyStatus_State_Idle,
        AutonomyStatus_State_Drive,
        AutonomyStatus_State_InStop,
        AutonomyStatus_State_Obstacle,
        AutonomyStatus_State_Error,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AutonomyStatus_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AutonomyStatus_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AutonomyStatus_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case AutonomyStatus_State_Idle:
    case AutonomyStatus_State_Drive:
    case AutonomyStatus_State_InStop:
    case AutonomyStatus_State_Obstacle:
    case AutonomyStatus_State_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AutonomyStatus_Telemetry

@implementation AutonomyStatus_Telemetry

@dynamic speed;
@dynamic fuel;
@dynamic hasPosition, position;

typedef struct AutonomyStatus_Telemetry__storage_ {
  uint32_t _has_storage_[1];
  Position *position;
  double speed;
  double fuel;
} AutonomyStatus_Telemetry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "speed",
        .dataTypeSpecific.clazz = Nil,
        .number = AutonomyStatus_Telemetry_FieldNumber_Speed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutonomyStatus_Telemetry__storage_, speed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "fuel",
        .dataTypeSpecific.clazz = Nil,
        .number = AutonomyStatus_Telemetry_FieldNumber_Fuel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutonomyStatus_Telemetry__storage_, fuel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = GPBObjCClass(Position),
        .number = AutonomyStatus_Telemetry_FieldNumber_Position,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AutonomyStatus_Telemetry__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutonomyStatus_Telemetry class]
                                     rootClass:[MissionModuleRoot class]
                                          file:MissionModuleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutonomyStatus_Telemetry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(AutonomyStatus)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutonomyCommand

@implementation AutonomyCommand

@dynamic stopsArray, stopsArray_Count;
@dynamic route;
@dynamic action;

typedef struct AutonomyCommand__storage_ {
  uint32_t _has_storage_[1];
  AutonomyCommand_Action action;
  NSMutableArray *stopsArray;
  NSString *route;
} AutonomyCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stopsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Station),
        .number = AutonomyCommand_FieldNumber_StopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AutonomyCommand__storage_, stopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "route",
        .dataTypeSpecific.clazz = Nil,
        .number = AutonomyCommand_FieldNumber_Route,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutonomyCommand__storage_, route),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = AutonomyCommand_Action_EnumDescriptor,
        .number = AutonomyCommand_FieldNumber_Action,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutonomyCommand__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutonomyCommand class]
                                     rootClass:[MissionModuleRoot class]
                                          file:MissionModuleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutonomyCommand__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AutonomyCommand_Action_RawValue(AutonomyCommand *message) {
  GPBDescriptor *descriptor = [AutonomyCommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutonomyCommand_FieldNumber_Action];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAutonomyCommand_Action_RawValue(AutonomyCommand *message, int32_t value) {
  GPBDescriptor *descriptor = [AutonomyCommand descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutonomyCommand_FieldNumber_Action];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum AutonomyCommand_Action

GPBEnumDescriptor *AutonomyCommand_Action_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NoAction\000Stop\000Start\000";
    static const int32_t values[] = {
        AutonomyCommand_Action_NoAction,
        AutonomyCommand_Action_Stop,
        AutonomyCommand_Action_Start,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AutonomyCommand_Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AutonomyCommand_Action_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AutonomyCommand_Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case AutonomyCommand_Action_NoAction:
    case AutonomyCommand_Action_Stop:
    case AutonomyCommand_Action_Start:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AutonomyError

@implementation AutonomyError

@dynamic finishedStopsArray, finishedStopsArray_Count;

typedef struct AutonomyError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *finishedStopsArray;
} AutonomyError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "finishedStopsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Station),
        .number = AutonomyError_FieldNumber_FinishedStopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AutonomyError__storage_, finishedStopsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutonomyError class]
                                     rootClass:[MissionModuleRoot class]
                                          file:MissionModuleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutonomyError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000finishedStops\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Station

@implementation Station

@dynamic name;
@dynamic hasPosition, position;

typedef struct Station__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  Position *position;
} Station__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Station_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Station__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "position",
        .dataTypeSpecific.clazz = GPBObjCClass(Position),
        .number = Station_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Station__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Station class]
                                     rootClass:[MissionModuleRoot class]
                                          file:MissionModuleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Station__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Position

@implementation Position

@dynamic latitude;
@dynamic longitude;
@dynamic altitude;

typedef struct Position__storage_ {
  uint32_t _has_storage_[1];
  double latitude;
  double longitude;
  double altitude;
} Position__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.clazz = Nil,
        .number = Position_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Position__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.clazz = Nil,
        .number = Position_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Position__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "altitude",
        .dataTypeSpecific.clazz = Nil,
        .number = Position_FieldNumber_Altitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Position__storage_, altitude),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Position class]
                                     rootClass:[MissionModuleRoot class]
                                          file:MissionModuleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Position__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
