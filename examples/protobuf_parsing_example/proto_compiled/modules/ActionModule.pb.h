// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/ActionModule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fActionModule_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fActionModule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fActionModule_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fActionModule_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fActionModule_2eproto;
namespace ActionModule {
class ActionCommand;
struct ActionCommandDefaultTypeInternal;
extern ActionCommandDefaultTypeInternal _ActionCommand_default_instance_;
class ActionError;
struct ActionErrorDefaultTypeInternal;
extern ActionErrorDefaultTypeInternal _ActionError_default_instance_;
class ActionStatus;
struct ActionStatusDefaultTypeInternal;
extern ActionStatusDefaultTypeInternal _ActionStatus_default_instance_;
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class GreenButtonCommand;
struct GreenButtonCommandDefaultTypeInternal;
extern GreenButtonCommandDefaultTypeInternal _GreenButtonCommand_default_instance_;
class GreenButtonError;
struct GreenButtonErrorDefaultTypeInternal;
extern GreenButtonErrorDefaultTypeInternal _GreenButtonError_default_instance_;
class GreenButtonStatus;
struct GreenButtonStatusDefaultTypeInternal;
extern GreenButtonStatusDefaultTypeInternal _GreenButtonStatus_default_instance_;
class RedButtonCommand;
struct RedButtonCommandDefaultTypeInternal;
extern RedButtonCommandDefaultTypeInternal _RedButtonCommand_default_instance_;
class RedButtonError;
struct RedButtonErrorDefaultTypeInternal;
extern RedButtonErrorDefaultTypeInternal _RedButtonError_default_instance_;
class RedButtonStatus;
struct RedButtonStatusDefaultTypeInternal;
extern RedButtonStatusDefaultTypeInternal _RedButtonStatus_default_instance_;
class SystemLoggerCommand;
struct SystemLoggerCommandDefaultTypeInternal;
extern SystemLoggerCommandDefaultTypeInternal _SystemLoggerCommand_default_instance_;
class SystemLoggerError;
struct SystemLoggerErrorDefaultTypeInternal;
extern SystemLoggerErrorDefaultTypeInternal _SystemLoggerError_default_instance_;
class SystemLoggerStatus;
struct SystemLoggerStatusDefaultTypeInternal;
extern SystemLoggerStatusDefaultTypeInternal _SystemLoggerStatus_default_instance_;
class WatchdogCommand;
struct WatchdogCommandDefaultTypeInternal;
extern WatchdogCommandDefaultTypeInternal _WatchdogCommand_default_instance_;
class WatchdogError;
struct WatchdogErrorDefaultTypeInternal;
extern WatchdogErrorDefaultTypeInternal _WatchdogError_default_instance_;
class WatchdogStatus;
struct WatchdogStatusDefaultTypeInternal;
extern WatchdogStatusDefaultTypeInternal _WatchdogStatus_default_instance_;
}  // namespace ActionModule
PROTOBUF_NAMESPACE_OPEN
template<> ::ActionModule::ActionCommand* Arena::CreateMaybeMessage<::ActionModule::ActionCommand>(Arena*);
template<> ::ActionModule::ActionError* Arena::CreateMaybeMessage<::ActionModule::ActionError>(Arena*);
template<> ::ActionModule::ActionStatus* Arena::CreateMaybeMessage<::ActionModule::ActionStatus>(Arena*);
template<> ::ActionModule::Device* Arena::CreateMaybeMessage<::ActionModule::Device>(Arena*);
template<> ::ActionModule::GreenButtonCommand* Arena::CreateMaybeMessage<::ActionModule::GreenButtonCommand>(Arena*);
template<> ::ActionModule::GreenButtonError* Arena::CreateMaybeMessage<::ActionModule::GreenButtonError>(Arena*);
template<> ::ActionModule::GreenButtonStatus* Arena::CreateMaybeMessage<::ActionModule::GreenButtonStatus>(Arena*);
template<> ::ActionModule::RedButtonCommand* Arena::CreateMaybeMessage<::ActionModule::RedButtonCommand>(Arena*);
template<> ::ActionModule::RedButtonError* Arena::CreateMaybeMessage<::ActionModule::RedButtonError>(Arena*);
template<> ::ActionModule::RedButtonStatus* Arena::CreateMaybeMessage<::ActionModule::RedButtonStatus>(Arena*);
template<> ::ActionModule::SystemLoggerCommand* Arena::CreateMaybeMessage<::ActionModule::SystemLoggerCommand>(Arena*);
template<> ::ActionModule::SystemLoggerError* Arena::CreateMaybeMessage<::ActionModule::SystemLoggerError>(Arena*);
template<> ::ActionModule::SystemLoggerStatus* Arena::CreateMaybeMessage<::ActionModule::SystemLoggerStatus>(Arena*);
template<> ::ActionModule::WatchdogCommand* Arena::CreateMaybeMessage<::ActionModule::WatchdogCommand>(Arena*);
template<> ::ActionModule::WatchdogError* Arena::CreateMaybeMessage<::ActionModule::WatchdogError>(Arena*);
template<> ::ActionModule::WatchdogStatus* Arena::CreateMaybeMessage<::ActionModule::WatchdogStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ActionModule {

enum ActionError_Type : int {
  ActionError_Type_OK = 0,
  ActionError_Type_SERVER_ERROR = 1,
  ActionError_Type_ActionError_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActionError_Type_ActionError_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActionError_Type_IsValid(int value);
constexpr ActionError_Type ActionError_Type_Type_MIN = ActionError_Type_OK;
constexpr ActionError_Type ActionError_Type_Type_MAX = ActionError_Type_SERVER_ERROR;
constexpr int ActionError_Type_Type_ARRAYSIZE = ActionError_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionError_Type_descriptor();
template<typename T>
inline const std::string& ActionError_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionError_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionError_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionError_Type_descriptor(), enum_t_value);
}
inline bool ActionError_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionError_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionError_Type>(
    ActionError_Type_descriptor(), name, value);
}
enum Device_Module : int {
  Device_Module_RESERVED_MODULE = 0,
  Device_Module_ACTION_MODULE = 3,
  Device_Module_Device_Module_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Device_Module_Device_Module_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Device_Module_IsValid(int value);
constexpr Device_Module Device_Module_Module_MIN = Device_Module_RESERVED_MODULE;
constexpr Device_Module Device_Module_Module_MAX = Device_Module_ACTION_MODULE;
constexpr int Device_Module_Module_ARRAYSIZE = Device_Module_Module_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Device_Module_descriptor();
template<typename T>
inline const std::string& Device_Module_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Device_Module>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Device_Module_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Device_Module_descriptor(), enum_t_value);
}
inline bool Device_Module_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Device_Module* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Device_Module>(
    Device_Module_descriptor(), name, value);
}
enum Device_DeviceType : int {
  Device_DeviceType_GREEN_BUTTON = 0,
  Device_DeviceType_RED_BUTTON = 1,
  Device_DeviceType_WATCHDOG = 2,
  Device_DeviceType_LOGGER = 3,
  Device_DeviceType_Device_DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Device_DeviceType_Device_DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Device_DeviceType_IsValid(int value);
constexpr Device_DeviceType Device_DeviceType_DeviceType_MIN = Device_DeviceType_GREEN_BUTTON;
constexpr Device_DeviceType Device_DeviceType_DeviceType_MAX = Device_DeviceType_LOGGER;
constexpr int Device_DeviceType_DeviceType_ARRAYSIZE = Device_DeviceType_DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Device_DeviceType_descriptor();
template<typename T>
inline const std::string& Device_DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Device_DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Device_DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Device_DeviceType_descriptor(), enum_t_value);
}
inline bool Device_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Device_DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Device_DeviceType>(
    Device_DeviceType_descriptor(), name, value);
}
enum SystemLoggerStatus_Verbosity : int {
  SystemLoggerStatus_Verbosity_DEBUG = 0,
  SystemLoggerStatus_Verbosity_INFO = 5,
  SystemLoggerStatus_Verbosity_WARNING = 10,
  SystemLoggerStatus_Verbosity_ERROR = 15,
  SystemLoggerStatus_Verbosity_SystemLoggerStatus_Verbosity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SystemLoggerStatus_Verbosity_SystemLoggerStatus_Verbosity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SystemLoggerStatus_Verbosity_IsValid(int value);
constexpr SystemLoggerStatus_Verbosity SystemLoggerStatus_Verbosity_Verbosity_MIN = SystemLoggerStatus_Verbosity_DEBUG;
constexpr SystemLoggerStatus_Verbosity SystemLoggerStatus_Verbosity_Verbosity_MAX = SystemLoggerStatus_Verbosity_ERROR;
constexpr int SystemLoggerStatus_Verbosity_Verbosity_ARRAYSIZE = SystemLoggerStatus_Verbosity_Verbosity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemLoggerStatus_Verbosity_descriptor();
template<typename T>
inline const std::string& SystemLoggerStatus_Verbosity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemLoggerStatus_Verbosity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemLoggerStatus_Verbosity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemLoggerStatus_Verbosity_descriptor(), enum_t_value);
}
inline bool SystemLoggerStatus_Verbosity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemLoggerStatus_Verbosity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemLoggerStatus_Verbosity>(
    SystemLoggerStatus_Verbosity_descriptor(), name, value);
}
enum SystemLoggerCommand_Command : int {
  SystemLoggerCommand_Command_LOG = 0,
  SystemLoggerCommand_Command_SystemLoggerCommand_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SystemLoggerCommand_Command_SystemLoggerCommand_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SystemLoggerCommand_Command_IsValid(int value);
constexpr SystemLoggerCommand_Command SystemLoggerCommand_Command_Command_MIN = SystemLoggerCommand_Command_LOG;
constexpr SystemLoggerCommand_Command SystemLoggerCommand_Command_Command_MAX = SystemLoggerCommand_Command_LOG;
constexpr int SystemLoggerCommand_Command_Command_ARRAYSIZE = SystemLoggerCommand_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemLoggerCommand_Command_descriptor();
template<typename T>
inline const std::string& SystemLoggerCommand_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemLoggerCommand_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemLoggerCommand_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemLoggerCommand_Command_descriptor(), enum_t_value);
}
inline bool SystemLoggerCommand_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemLoggerCommand_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemLoggerCommand_Command>(
    SystemLoggerCommand_Command_descriptor(), name, value);
}
enum GreenButtonCommand_Command : int {
  GreenButtonCommand_Command_PRESS = 0,
  GreenButtonCommand_Command_GreenButtonCommand_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GreenButtonCommand_Command_GreenButtonCommand_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GreenButtonCommand_Command_IsValid(int value);
constexpr GreenButtonCommand_Command GreenButtonCommand_Command_Command_MIN = GreenButtonCommand_Command_PRESS;
constexpr GreenButtonCommand_Command GreenButtonCommand_Command_Command_MAX = GreenButtonCommand_Command_PRESS;
constexpr int GreenButtonCommand_Command_Command_ARRAYSIZE = GreenButtonCommand_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GreenButtonCommand_Command_descriptor();
template<typename T>
inline const std::string& GreenButtonCommand_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GreenButtonCommand_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GreenButtonCommand_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GreenButtonCommand_Command_descriptor(), enum_t_value);
}
inline bool GreenButtonCommand_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GreenButtonCommand_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GreenButtonCommand_Command>(
    GreenButtonCommand_Command_descriptor(), name, value);
}
enum RedButtonCommand_Command : int {
  RedButtonCommand_Command_PRESS = 0,
  RedButtonCommand_Command_RedButtonCommand_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RedButtonCommand_Command_RedButtonCommand_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RedButtonCommand_Command_IsValid(int value);
constexpr RedButtonCommand_Command RedButtonCommand_Command_Command_MIN = RedButtonCommand_Command_PRESS;
constexpr RedButtonCommand_Command RedButtonCommand_Command_Command_MAX = RedButtonCommand_Command_PRESS;
constexpr int RedButtonCommand_Command_Command_ARRAYSIZE = RedButtonCommand_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RedButtonCommand_Command_descriptor();
template<typename T>
inline const std::string& RedButtonCommand_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RedButtonCommand_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RedButtonCommand_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RedButtonCommand_Command_descriptor(), enum_t_value);
}
inline bool RedButtonCommand_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RedButtonCommand_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RedButtonCommand_Command>(
    RedButtonCommand_Command_descriptor(), name, value);
}
enum WatchdogCommand_Command : int {
  WatchdogCommand_Command_RESET = 0,
  WatchdogCommand_Command_WatchdogCommand_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WatchdogCommand_Command_WatchdogCommand_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WatchdogCommand_Command_IsValid(int value);
constexpr WatchdogCommand_Command WatchdogCommand_Command_Command_MIN = WatchdogCommand_Command_RESET;
constexpr WatchdogCommand_Command WatchdogCommand_Command_Command_MAX = WatchdogCommand_Command_RESET;
constexpr int WatchdogCommand_Command_Command_ARRAYSIZE = WatchdogCommand_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WatchdogCommand_Command_descriptor();
template<typename T>
inline const std::string& WatchdogCommand_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WatchdogCommand_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WatchdogCommand_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WatchdogCommand_Command_descriptor(), enum_t_value);
}
inline bool WatchdogCommand_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WatchdogCommand_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WatchdogCommand_Command>(
    WatchdogCommand_Command_descriptor(), name, value);
}
// ===================================================================

class ActionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.ActionStatus) */ {
 public:
  inline ActionStatus() : ActionStatus(nullptr) {}
  ~ActionStatus() override;
  explicit constexpr ActionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionStatus(const ActionStatus& from);
  ActionStatus(ActionStatus&& from) noexcept
    : ActionStatus() {
    *this = ::std::move(from);
  }

  inline ActionStatus& operator=(const ActionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionStatus& operator=(ActionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionStatus& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceStatusTypeCase {
    kSystemLoggerStatus = 2,
    kGreenButtonStatus = 3,
    kRedButtonStatus = 4,
    kWatchdogStatus = 5,
    DEVICESTATUSTYPE_NOT_SET = 0,
  };

  static inline const ActionStatus* internal_default_instance() {
    return reinterpret_cast<const ActionStatus*>(
               &_ActionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ActionStatus& a, ActionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionStatus* New() const final {
    return new ActionStatus();
  }

  ActionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.ActionStatus";
  }
  protected:
  explicit ActionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kSystemLoggerStatusFieldNumber = 2,
    kGreenButtonStatusFieldNumber = 3,
    kRedButtonStatusFieldNumber = 4,
    kWatchdogStatusFieldNumber = 5,
  };
  // .ActionModule.Device device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ActionModule::Device& device() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::Device* release_device();
  ::ActionModule::Device* mutable_device();
  void set_allocated_device(::ActionModule::Device* device);
  private:
  const ::ActionModule::Device& _internal_device() const;
  ::ActionModule::Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ActionModule::Device* device);
  ::ActionModule::Device* unsafe_arena_release_device();

  // .ActionModule.SystemLoggerStatus systemLoggerStatus = 2;
  bool has_systemloggerstatus() const;
  private:
  bool _internal_has_systemloggerstatus() const;
  public:
  void clear_systemloggerstatus();
  const ::ActionModule::SystemLoggerStatus& systemloggerstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::SystemLoggerStatus* release_systemloggerstatus();
  ::ActionModule::SystemLoggerStatus* mutable_systemloggerstatus();
  void set_allocated_systemloggerstatus(::ActionModule::SystemLoggerStatus* systemloggerstatus);
  private:
  const ::ActionModule::SystemLoggerStatus& _internal_systemloggerstatus() const;
  ::ActionModule::SystemLoggerStatus* _internal_mutable_systemloggerstatus();
  public:
  void unsafe_arena_set_allocated_systemloggerstatus(
      ::ActionModule::SystemLoggerStatus* systemloggerstatus);
  ::ActionModule::SystemLoggerStatus* unsafe_arena_release_systemloggerstatus();

  // .ActionModule.GreenButtonStatus greenButtonStatus = 3;
  bool has_greenbuttonstatus() const;
  private:
  bool _internal_has_greenbuttonstatus() const;
  public:
  void clear_greenbuttonstatus();
  const ::ActionModule::GreenButtonStatus& greenbuttonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::GreenButtonStatus* release_greenbuttonstatus();
  ::ActionModule::GreenButtonStatus* mutable_greenbuttonstatus();
  void set_allocated_greenbuttonstatus(::ActionModule::GreenButtonStatus* greenbuttonstatus);
  private:
  const ::ActionModule::GreenButtonStatus& _internal_greenbuttonstatus() const;
  ::ActionModule::GreenButtonStatus* _internal_mutable_greenbuttonstatus();
  public:
  void unsafe_arena_set_allocated_greenbuttonstatus(
      ::ActionModule::GreenButtonStatus* greenbuttonstatus);
  ::ActionModule::GreenButtonStatus* unsafe_arena_release_greenbuttonstatus();

  // .ActionModule.RedButtonStatus redButtonStatus = 4;
  bool has_redbuttonstatus() const;
  private:
  bool _internal_has_redbuttonstatus() const;
  public:
  void clear_redbuttonstatus();
  const ::ActionModule::RedButtonStatus& redbuttonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::RedButtonStatus* release_redbuttonstatus();
  ::ActionModule::RedButtonStatus* mutable_redbuttonstatus();
  void set_allocated_redbuttonstatus(::ActionModule::RedButtonStatus* redbuttonstatus);
  private:
  const ::ActionModule::RedButtonStatus& _internal_redbuttonstatus() const;
  ::ActionModule::RedButtonStatus* _internal_mutable_redbuttonstatus();
  public:
  void unsafe_arena_set_allocated_redbuttonstatus(
      ::ActionModule::RedButtonStatus* redbuttonstatus);
  ::ActionModule::RedButtonStatus* unsafe_arena_release_redbuttonstatus();

  // .ActionModule.WatchdogStatus watchdogStatus = 5;
  bool has_watchdogstatus() const;
  private:
  bool _internal_has_watchdogstatus() const;
  public:
  void clear_watchdogstatus();
  const ::ActionModule::WatchdogStatus& watchdogstatus() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::WatchdogStatus* release_watchdogstatus();
  ::ActionModule::WatchdogStatus* mutable_watchdogstatus();
  void set_allocated_watchdogstatus(::ActionModule::WatchdogStatus* watchdogstatus);
  private:
  const ::ActionModule::WatchdogStatus& _internal_watchdogstatus() const;
  ::ActionModule::WatchdogStatus* _internal_mutable_watchdogstatus();
  public:
  void unsafe_arena_set_allocated_watchdogstatus(
      ::ActionModule::WatchdogStatus* watchdogstatus);
  ::ActionModule::WatchdogStatus* unsafe_arena_release_watchdogstatus();

  void clear_DeviceStatusType();
  DeviceStatusTypeCase DeviceStatusType_case() const;
  // @@protoc_insertion_point(class_scope:ActionModule.ActionStatus)
 private:
  class _Internal;
  void set_has_systemloggerstatus();
  void set_has_greenbuttonstatus();
  void set_has_redbuttonstatus();
  void set_has_watchdogstatus();

  inline bool has_DeviceStatusType() const;
  inline void clear_has_DeviceStatusType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ActionModule::Device* device_;
  union DeviceStatusTypeUnion {
    constexpr DeviceStatusTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ActionModule::SystemLoggerStatus* systemloggerstatus_;
    ::ActionModule::GreenButtonStatus* greenbuttonstatus_;
    ::ActionModule::RedButtonStatus* redbuttonstatus_;
    ::ActionModule::WatchdogStatus* watchdogstatus_;
  } DeviceStatusType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class ActionCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.ActionCommand) */ {
 public:
  inline ActionCommand() : ActionCommand(nullptr) {}
  ~ActionCommand() override;
  explicit constexpr ActionCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionCommand(const ActionCommand& from);
  ActionCommand(ActionCommand&& from) noexcept
    : ActionCommand() {
    *this = ::std::move(from);
  }

  inline ActionCommand& operator=(const ActionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCommand& operator=(ActionCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionCommand& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceCommandTypeCase {
    kGreenButtonCommand = 2,
    kRedButtonCommand = 3,
    kWatchdogCommand = 4,
    kSystemLoggerCommand = 5,
    DEVICECOMMANDTYPE_NOT_SET = 0,
  };

  static inline const ActionCommand* internal_default_instance() {
    return reinterpret_cast<const ActionCommand*>(
               &_ActionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ActionCommand& a, ActionCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionCommand* New() const final {
    return new ActionCommand();
  }

  ActionCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.ActionCommand";
  }
  protected:
  explicit ActionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kGreenButtonCommandFieldNumber = 2,
    kRedButtonCommandFieldNumber = 3,
    kWatchdogCommandFieldNumber = 4,
    kSystemLoggerCommandFieldNumber = 5,
  };
  // .ActionModule.Device device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ActionModule::Device& device() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::Device* release_device();
  ::ActionModule::Device* mutable_device();
  void set_allocated_device(::ActionModule::Device* device);
  private:
  const ::ActionModule::Device& _internal_device() const;
  ::ActionModule::Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ActionModule::Device* device);
  ::ActionModule::Device* unsafe_arena_release_device();

  // .ActionModule.GreenButtonCommand greenButtonCommand = 2;
  bool has_greenbuttoncommand() const;
  private:
  bool _internal_has_greenbuttoncommand() const;
  public:
  void clear_greenbuttoncommand();
  const ::ActionModule::GreenButtonCommand& greenbuttoncommand() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::GreenButtonCommand* release_greenbuttoncommand();
  ::ActionModule::GreenButtonCommand* mutable_greenbuttoncommand();
  void set_allocated_greenbuttoncommand(::ActionModule::GreenButtonCommand* greenbuttoncommand);
  private:
  const ::ActionModule::GreenButtonCommand& _internal_greenbuttoncommand() const;
  ::ActionModule::GreenButtonCommand* _internal_mutable_greenbuttoncommand();
  public:
  void unsafe_arena_set_allocated_greenbuttoncommand(
      ::ActionModule::GreenButtonCommand* greenbuttoncommand);
  ::ActionModule::GreenButtonCommand* unsafe_arena_release_greenbuttoncommand();

  // .ActionModule.RedButtonCommand redButtonCommand = 3;
  bool has_redbuttoncommand() const;
  private:
  bool _internal_has_redbuttoncommand() const;
  public:
  void clear_redbuttoncommand();
  const ::ActionModule::RedButtonCommand& redbuttoncommand() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::RedButtonCommand* release_redbuttoncommand();
  ::ActionModule::RedButtonCommand* mutable_redbuttoncommand();
  void set_allocated_redbuttoncommand(::ActionModule::RedButtonCommand* redbuttoncommand);
  private:
  const ::ActionModule::RedButtonCommand& _internal_redbuttoncommand() const;
  ::ActionModule::RedButtonCommand* _internal_mutable_redbuttoncommand();
  public:
  void unsafe_arena_set_allocated_redbuttoncommand(
      ::ActionModule::RedButtonCommand* redbuttoncommand);
  ::ActionModule::RedButtonCommand* unsafe_arena_release_redbuttoncommand();

  // .ActionModule.WatchdogCommand watchdogCommand = 4;
  bool has_watchdogcommand() const;
  private:
  bool _internal_has_watchdogcommand() const;
  public:
  void clear_watchdogcommand();
  const ::ActionModule::WatchdogCommand& watchdogcommand() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::WatchdogCommand* release_watchdogcommand();
  ::ActionModule::WatchdogCommand* mutable_watchdogcommand();
  void set_allocated_watchdogcommand(::ActionModule::WatchdogCommand* watchdogcommand);
  private:
  const ::ActionModule::WatchdogCommand& _internal_watchdogcommand() const;
  ::ActionModule::WatchdogCommand* _internal_mutable_watchdogcommand();
  public:
  void unsafe_arena_set_allocated_watchdogcommand(
      ::ActionModule::WatchdogCommand* watchdogcommand);
  ::ActionModule::WatchdogCommand* unsafe_arena_release_watchdogcommand();

  // .ActionModule.SystemLoggerCommand systemLoggerCommand = 5;
  bool has_systemloggercommand() const;
  private:
  bool _internal_has_systemloggercommand() const;
  public:
  void clear_systemloggercommand();
  const ::ActionModule::SystemLoggerCommand& systemloggercommand() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::SystemLoggerCommand* release_systemloggercommand();
  ::ActionModule::SystemLoggerCommand* mutable_systemloggercommand();
  void set_allocated_systemloggercommand(::ActionModule::SystemLoggerCommand* systemloggercommand);
  private:
  const ::ActionModule::SystemLoggerCommand& _internal_systemloggercommand() const;
  ::ActionModule::SystemLoggerCommand* _internal_mutable_systemloggercommand();
  public:
  void unsafe_arena_set_allocated_systemloggercommand(
      ::ActionModule::SystemLoggerCommand* systemloggercommand);
  ::ActionModule::SystemLoggerCommand* unsafe_arena_release_systemloggercommand();

  void clear_DeviceCommandType();
  DeviceCommandTypeCase DeviceCommandType_case() const;
  // @@protoc_insertion_point(class_scope:ActionModule.ActionCommand)
 private:
  class _Internal;
  void set_has_greenbuttoncommand();
  void set_has_redbuttoncommand();
  void set_has_watchdogcommand();
  void set_has_systemloggercommand();

  inline bool has_DeviceCommandType() const;
  inline void clear_has_DeviceCommandType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ActionModule::Device* device_;
  union DeviceCommandTypeUnion {
    constexpr DeviceCommandTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ActionModule::GreenButtonCommand* greenbuttoncommand_;
    ::ActionModule::RedButtonCommand* redbuttoncommand_;
    ::ActionModule::WatchdogCommand* watchdogcommand_;
    ::ActionModule::SystemLoggerCommand* systemloggercommand_;
  } DeviceCommandType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class ActionError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.ActionError) */ {
 public:
  inline ActionError() : ActionError(nullptr) {}
  ~ActionError() override;
  explicit constexpr ActionError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionError(const ActionError& from);
  ActionError(ActionError&& from) noexcept
    : ActionError() {
    *this = ::std::move(from);
  }

  inline ActionError& operator=(const ActionError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionError& operator=(ActionError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionError& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceErrorTypeCase {
    kGreenButtonError = 3,
    kRedButtonError = 4,
    kWatchdogError = 5,
    kSystemLoggerError = 6,
    DEVICEERRORTYPE_NOT_SET = 0,
  };

  static inline const ActionError* internal_default_instance() {
    return reinterpret_cast<const ActionError*>(
               &_ActionError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionError& a, ActionError& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionError* New() const final {
    return new ActionError();
  }

  ActionError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.ActionError";
  }
  protected:
  explicit ActionError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionError_Type Type;
  static constexpr Type OK =
    ActionError_Type_OK;
  static constexpr Type SERVER_ERROR =
    ActionError_Type_SERVER_ERROR;
  static inline bool Type_IsValid(int value) {
    return ActionError_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ActionError_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ActionError_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ActionError_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ActionError_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ActionError_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ActionError_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kTypeFieldNumber = 2,
    kGreenButtonErrorFieldNumber = 3,
    kRedButtonErrorFieldNumber = 4,
    kWatchdogErrorFieldNumber = 5,
    kSystemLoggerErrorFieldNumber = 6,
  };
  // .ActionModule.Device device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ActionModule::Device& device() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::Device* release_device();
  ::ActionModule::Device* mutable_device();
  void set_allocated_device(::ActionModule::Device* device);
  private:
  const ::ActionModule::Device& _internal_device() const;
  ::ActionModule::Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ActionModule::Device* device);
  ::ActionModule::Device* unsafe_arena_release_device();

  // .ActionModule.ActionError.Type type = 2;
  void clear_type();
  ::ActionModule::ActionError_Type type() const;
  void set_type(::ActionModule::ActionError_Type value);
  private:
  ::ActionModule::ActionError_Type _internal_type() const;
  void _internal_set_type(::ActionModule::ActionError_Type value);
  public:

  // .ActionModule.GreenButtonError greenButtonError = 3;
  bool has_greenbuttonerror() const;
  private:
  bool _internal_has_greenbuttonerror() const;
  public:
  void clear_greenbuttonerror();
  const ::ActionModule::GreenButtonError& greenbuttonerror() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::GreenButtonError* release_greenbuttonerror();
  ::ActionModule::GreenButtonError* mutable_greenbuttonerror();
  void set_allocated_greenbuttonerror(::ActionModule::GreenButtonError* greenbuttonerror);
  private:
  const ::ActionModule::GreenButtonError& _internal_greenbuttonerror() const;
  ::ActionModule::GreenButtonError* _internal_mutable_greenbuttonerror();
  public:
  void unsafe_arena_set_allocated_greenbuttonerror(
      ::ActionModule::GreenButtonError* greenbuttonerror);
  ::ActionModule::GreenButtonError* unsafe_arena_release_greenbuttonerror();

  // .ActionModule.RedButtonError redButtonError = 4;
  bool has_redbuttonerror() const;
  private:
  bool _internal_has_redbuttonerror() const;
  public:
  void clear_redbuttonerror();
  const ::ActionModule::RedButtonError& redbuttonerror() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::RedButtonError* release_redbuttonerror();
  ::ActionModule::RedButtonError* mutable_redbuttonerror();
  void set_allocated_redbuttonerror(::ActionModule::RedButtonError* redbuttonerror);
  private:
  const ::ActionModule::RedButtonError& _internal_redbuttonerror() const;
  ::ActionModule::RedButtonError* _internal_mutable_redbuttonerror();
  public:
  void unsafe_arena_set_allocated_redbuttonerror(
      ::ActionModule::RedButtonError* redbuttonerror);
  ::ActionModule::RedButtonError* unsafe_arena_release_redbuttonerror();

  // .ActionModule.WatchdogError watchdogError = 5;
  bool has_watchdogerror() const;
  private:
  bool _internal_has_watchdogerror() const;
  public:
  void clear_watchdogerror();
  const ::ActionModule::WatchdogError& watchdogerror() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::WatchdogError* release_watchdogerror();
  ::ActionModule::WatchdogError* mutable_watchdogerror();
  void set_allocated_watchdogerror(::ActionModule::WatchdogError* watchdogerror);
  private:
  const ::ActionModule::WatchdogError& _internal_watchdogerror() const;
  ::ActionModule::WatchdogError* _internal_mutable_watchdogerror();
  public:
  void unsafe_arena_set_allocated_watchdogerror(
      ::ActionModule::WatchdogError* watchdogerror);
  ::ActionModule::WatchdogError* unsafe_arena_release_watchdogerror();

  // .ActionModule.SystemLoggerError systemLoggerError = 6;
  bool has_systemloggererror() const;
  private:
  bool _internal_has_systemloggererror() const;
  public:
  void clear_systemloggererror();
  const ::ActionModule::SystemLoggerError& systemloggererror() const;
  PROTOBUF_MUST_USE_RESULT ::ActionModule::SystemLoggerError* release_systemloggererror();
  ::ActionModule::SystemLoggerError* mutable_systemloggererror();
  void set_allocated_systemloggererror(::ActionModule::SystemLoggerError* systemloggererror);
  private:
  const ::ActionModule::SystemLoggerError& _internal_systemloggererror() const;
  ::ActionModule::SystemLoggerError* _internal_mutable_systemloggererror();
  public:
  void unsafe_arena_set_allocated_systemloggererror(
      ::ActionModule::SystemLoggerError* systemloggererror);
  ::ActionModule::SystemLoggerError* unsafe_arena_release_systemloggererror();

  void clear_DeviceErrorType();
  DeviceErrorTypeCase DeviceErrorType_case() const;
  // @@protoc_insertion_point(class_scope:ActionModule.ActionError)
 private:
  class _Internal;
  void set_has_greenbuttonerror();
  void set_has_redbuttonerror();
  void set_has_watchdogerror();
  void set_has_systemloggererror();

  inline bool has_DeviceErrorType() const;
  inline void clear_has_DeviceErrorType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ActionModule::Device* device_;
  int type_;
  union DeviceErrorTypeUnion {
    constexpr DeviceErrorTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ActionModule::GreenButtonError* greenbuttonerror_;
    ::ActionModule::RedButtonError* redbuttonerror_;
    ::ActionModule::WatchdogError* watchdogerror_;
    ::ActionModule::SystemLoggerError* systemloggererror_;
  } DeviceErrorType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class Device final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() override;
  explicit constexpr Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Device(const Device& from);
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Device* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const final {
    return new Device();
  }

  Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Device& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Device& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Device* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.Device";
  }
  protected:
  explicit Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Device_Module Module;
  static constexpr Module RESERVED_MODULE =
    Device_Module_RESERVED_MODULE;
  static constexpr Module ACTION_MODULE =
    Device_Module_ACTION_MODULE;
  static inline bool Module_IsValid(int value) {
    return Device_Module_IsValid(value);
  }
  static constexpr Module Module_MIN =
    Device_Module_Module_MIN;
  static constexpr Module Module_MAX =
    Device_Module_Module_MAX;
  static constexpr int Module_ARRAYSIZE =
    Device_Module_Module_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Module_descriptor() {
    return Device_Module_descriptor();
  }
  template<typename T>
  static inline const std::string& Module_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Module>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Module_Name.");
    return Device_Module_Name(enum_t_value);
  }
  static inline bool Module_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Module* value) {
    return Device_Module_Parse(name, value);
  }

  typedef Device_DeviceType DeviceType;
  static constexpr DeviceType GREEN_BUTTON =
    Device_DeviceType_GREEN_BUTTON;
  static constexpr DeviceType RED_BUTTON =
    Device_DeviceType_RED_BUTTON;
  static constexpr DeviceType WATCHDOG =
    Device_DeviceType_WATCHDOG;
  static constexpr DeviceType LOGGER =
    Device_DeviceType_LOGGER;
  static inline bool DeviceType_IsValid(int value) {
    return Device_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN =
    Device_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX =
    Device_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE =
    Device_DeviceType_DeviceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DeviceType_descriptor() {
    return Device_DeviceType_descriptor();
  }
  template<typename T>
  static inline const std::string& DeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceType_Name.");
    return Device_DeviceType_Name(enum_t_value);
  }
  static inline bool DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceType* value) {
    return Device_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceNameFieldNumber = 3,
    kModuleFieldNumber = 1,
    kDeviceTypeFieldNumber = 2,
  };
  // string deviceName = 3;
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_MUST_USE_RESULT std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // .ActionModule.Device.Module module = 1;
  void clear_module();
  ::ActionModule::Device_Module module() const;
  void set_module(::ActionModule::Device_Module value);
  private:
  ::ActionModule::Device_Module _internal_module() const;
  void _internal_set_module(::ActionModule::Device_Module value);
  public:

  // .ActionModule.Device.DeviceType deviceType = 2;
  void clear_devicetype();
  ::ActionModule::Device_DeviceType devicetype() const;
  void set_devicetype(::ActionModule::Device_DeviceType value);
  private:
  ::ActionModule::Device_DeviceType _internal_devicetype() const;
  void _internal_set_devicetype(::ActionModule::Device_DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
  int module_;
  int devicetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class SystemLoggerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.SystemLoggerStatus) */ {
 public:
  inline SystemLoggerStatus() : SystemLoggerStatus(nullptr) {}
  ~SystemLoggerStatus() override;
  explicit constexpr SystemLoggerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemLoggerStatus(const SystemLoggerStatus& from);
  SystemLoggerStatus(SystemLoggerStatus&& from) noexcept
    : SystemLoggerStatus() {
    *this = ::std::move(from);
  }

  inline SystemLoggerStatus& operator=(const SystemLoggerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemLoggerStatus& operator=(SystemLoggerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemLoggerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemLoggerStatus* internal_default_instance() {
    return reinterpret_cast<const SystemLoggerStatus*>(
               &_SystemLoggerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SystemLoggerStatus& a, SystemLoggerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemLoggerStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemLoggerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemLoggerStatus* New() const final {
    return new SystemLoggerStatus();
  }

  SystemLoggerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemLoggerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemLoggerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SystemLoggerStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemLoggerStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.SystemLoggerStatus";
  }
  protected:
  explicit SystemLoggerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SystemLoggerStatus_Verbosity Verbosity;
  static constexpr Verbosity DEBUG =
    SystemLoggerStatus_Verbosity_DEBUG;
  static constexpr Verbosity INFO =
    SystemLoggerStatus_Verbosity_INFO;
  static constexpr Verbosity WARNING =
    SystemLoggerStatus_Verbosity_WARNING;
  static constexpr Verbosity ERROR =
    SystemLoggerStatus_Verbosity_ERROR;
  static inline bool Verbosity_IsValid(int value) {
    return SystemLoggerStatus_Verbosity_IsValid(value);
  }
  static constexpr Verbosity Verbosity_MIN =
    SystemLoggerStatus_Verbosity_Verbosity_MIN;
  static constexpr Verbosity Verbosity_MAX =
    SystemLoggerStatus_Verbosity_Verbosity_MAX;
  static constexpr int Verbosity_ARRAYSIZE =
    SystemLoggerStatus_Verbosity_Verbosity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Verbosity_descriptor() {
    return SystemLoggerStatus_Verbosity_descriptor();
  }
  template<typename T>
  static inline const std::string& Verbosity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Verbosity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Verbosity_Name.");
    return SystemLoggerStatus_Verbosity_Name(enum_t_value);
  }
  static inline bool Verbosity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Verbosity* value) {
    return SystemLoggerStatus_Verbosity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 2,
    kSourceDeviceFieldNumber = 1,
    kVerbosityFieldNumber = 3,
  };
  // repeated string logs = 2;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  const std::string& logs(int index) const;
  std::string* mutable_logs(int index);
  void set_logs(int index, const std::string& value);
  void set_logs(int index, std::string&& value);
  void set_logs(int index, const char* value);
  void set_logs(int index, const char* value, size_t size);
  std::string* add_logs();
  void add_logs(const std::string& value);
  void add_logs(std::string&& value);
  void add_logs(const char* value);
  void add_logs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& logs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_logs();
  private:
  const std::string& _internal_logs(int index) const;
  std::string* _internal_add_logs();
  public:

  // string sourceDevice = 1;
  void clear_sourcedevice();
  const std::string& sourcedevice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcedevice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcedevice();
  PROTOBUF_MUST_USE_RESULT std::string* release_sourcedevice();
  void set_allocated_sourcedevice(std::string* sourcedevice);
  private:
  const std::string& _internal_sourcedevice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcedevice(const std::string& value);
  std::string* _internal_mutable_sourcedevice();
  public:

  // .ActionModule.SystemLoggerStatus.Verbosity verbosity = 3;
  void clear_verbosity();
  ::ActionModule::SystemLoggerStatus_Verbosity verbosity() const;
  void set_verbosity(::ActionModule::SystemLoggerStatus_Verbosity value);
  private:
  ::ActionModule::SystemLoggerStatus_Verbosity _internal_verbosity() const;
  void _internal_set_verbosity(::ActionModule::SystemLoggerStatus_Verbosity value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.SystemLoggerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> logs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcedevice_;
  int verbosity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class GreenButtonStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.GreenButtonStatus) */ {
 public:
  inline GreenButtonStatus() : GreenButtonStatus(nullptr) {}
  ~GreenButtonStatus() override;
  explicit constexpr GreenButtonStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GreenButtonStatus(const GreenButtonStatus& from);
  GreenButtonStatus(GreenButtonStatus&& from) noexcept
    : GreenButtonStatus() {
    *this = ::std::move(from);
  }

  inline GreenButtonStatus& operator=(const GreenButtonStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GreenButtonStatus& operator=(GreenButtonStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GreenButtonStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const GreenButtonStatus* internal_default_instance() {
    return reinterpret_cast<const GreenButtonStatus*>(
               &_GreenButtonStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GreenButtonStatus& a, GreenButtonStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GreenButtonStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GreenButtonStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GreenButtonStatus* New() const final {
    return new GreenButtonStatus();
  }

  GreenButtonStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GreenButtonStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GreenButtonStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GreenButtonStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreenButtonStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.GreenButtonStatus";
  }
  protected:
  explicit GreenButtonStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPressedFieldNumber = 1,
    kIsAliveFieldNumber = 2,
  };
  // bool isPressed = 1;
  void clear_ispressed();
  bool ispressed() const;
  void set_ispressed(bool value);
  private:
  bool _internal_ispressed() const;
  void _internal_set_ispressed(bool value);
  public:

  // bool isAlive = 2;
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool value);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.GreenButtonStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ispressed_;
  bool isalive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class RedButtonStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.RedButtonStatus) */ {
 public:
  inline RedButtonStatus() : RedButtonStatus(nullptr) {}
  ~RedButtonStatus() override;
  explicit constexpr RedButtonStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedButtonStatus(const RedButtonStatus& from);
  RedButtonStatus(RedButtonStatus&& from) noexcept
    : RedButtonStatus() {
    *this = ::std::move(from);
  }

  inline RedButtonStatus& operator=(const RedButtonStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedButtonStatus& operator=(RedButtonStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedButtonStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedButtonStatus* internal_default_instance() {
    return reinterpret_cast<const RedButtonStatus*>(
               &_RedButtonStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RedButtonStatus& a, RedButtonStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RedButtonStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedButtonStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedButtonStatus* New() const final {
    return new RedButtonStatus();
  }

  RedButtonStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedButtonStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedButtonStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RedButtonStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedButtonStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.RedButtonStatus";
  }
  protected:
  explicit RedButtonStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPressedFieldNumber = 1,
  };
  // bool isPressed = 1;
  void clear_ispressed();
  bool ispressed() const;
  void set_ispressed(bool value);
  private:
  bool _internal_ispressed() const;
  void _internal_set_ispressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.RedButtonStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ispressed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class WatchdogStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.WatchdogStatus) */ {
 public:
  inline WatchdogStatus() : WatchdogStatus(nullptr) {}
  ~WatchdogStatus() override;
  explicit constexpr WatchdogStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchdogStatus(const WatchdogStatus& from);
  WatchdogStatus(WatchdogStatus&& from) noexcept
    : WatchdogStatus() {
    *this = ::std::move(from);
  }

  inline WatchdogStatus& operator=(const WatchdogStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchdogStatus& operator=(WatchdogStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchdogStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchdogStatus* internal_default_instance() {
    return reinterpret_cast<const WatchdogStatus*>(
               &_WatchdogStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WatchdogStatus& a, WatchdogStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchdogStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchdogStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchdogStatus* New() const final {
    return new WatchdogStatus();
  }

  WatchdogStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchdogStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchdogStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchdogStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchdogStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.WatchdogStatus";
  }
  protected:
  explicit WatchdogStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 2,
    kIsAliveFieldNumber = 1,
  };
  // string state = 2;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_MUST_USE_RESULT std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // bool isAlive = 1;
  void clear_isalive();
  bool isalive() const;
  void set_isalive(bool value);
  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.WatchdogStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  bool isalive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class SystemLoggerCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.SystemLoggerCommand) */ {
 public:
  inline SystemLoggerCommand() : SystemLoggerCommand(nullptr) {}
  ~SystemLoggerCommand() override;
  explicit constexpr SystemLoggerCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemLoggerCommand(const SystemLoggerCommand& from);
  SystemLoggerCommand(SystemLoggerCommand&& from) noexcept
    : SystemLoggerCommand() {
    *this = ::std::move(from);
  }

  inline SystemLoggerCommand& operator=(const SystemLoggerCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemLoggerCommand& operator=(SystemLoggerCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemLoggerCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemLoggerCommand* internal_default_instance() {
    return reinterpret_cast<const SystemLoggerCommand*>(
               &_SystemLoggerCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SystemLoggerCommand& a, SystemLoggerCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemLoggerCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemLoggerCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemLoggerCommand* New() const final {
    return new SystemLoggerCommand();
  }

  SystemLoggerCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemLoggerCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemLoggerCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SystemLoggerCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemLoggerCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.SystemLoggerCommand";
  }
  protected:
  explicit SystemLoggerCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SystemLoggerCommand_Command Command;
  static constexpr Command LOG =
    SystemLoggerCommand_Command_LOG;
  static inline bool Command_IsValid(int value) {
    return SystemLoggerCommand_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    SystemLoggerCommand_Command_Command_MIN;
  static constexpr Command Command_MAX =
    SystemLoggerCommand_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    SystemLoggerCommand_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return SystemLoggerCommand_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return SystemLoggerCommand_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return SystemLoggerCommand_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // .ActionModule.SystemLoggerCommand.Command command = 1;
  void clear_command();
  ::ActionModule::SystemLoggerCommand_Command command() const;
  void set_command(::ActionModule::SystemLoggerCommand_Command value);
  private:
  ::ActionModule::SystemLoggerCommand_Command _internal_command() const;
  void _internal_set_command(::ActionModule::SystemLoggerCommand_Command value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.SystemLoggerCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class GreenButtonCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.GreenButtonCommand) */ {
 public:
  inline GreenButtonCommand() : GreenButtonCommand(nullptr) {}
  ~GreenButtonCommand() override;
  explicit constexpr GreenButtonCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GreenButtonCommand(const GreenButtonCommand& from);
  GreenButtonCommand(GreenButtonCommand&& from) noexcept
    : GreenButtonCommand() {
    *this = ::std::move(from);
  }

  inline GreenButtonCommand& operator=(const GreenButtonCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline GreenButtonCommand& operator=(GreenButtonCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GreenButtonCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const GreenButtonCommand* internal_default_instance() {
    return reinterpret_cast<const GreenButtonCommand*>(
               &_GreenButtonCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GreenButtonCommand& a, GreenButtonCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(GreenButtonCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GreenButtonCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GreenButtonCommand* New() const final {
    return new GreenButtonCommand();
  }

  GreenButtonCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GreenButtonCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GreenButtonCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GreenButtonCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreenButtonCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.GreenButtonCommand";
  }
  protected:
  explicit GreenButtonCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GreenButtonCommand_Command Command;
  static constexpr Command PRESS =
    GreenButtonCommand_Command_PRESS;
  static inline bool Command_IsValid(int value) {
    return GreenButtonCommand_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    GreenButtonCommand_Command_Command_MIN;
  static constexpr Command Command_MAX =
    GreenButtonCommand_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    GreenButtonCommand_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return GreenButtonCommand_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return GreenButtonCommand_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return GreenButtonCommand_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // .ActionModule.GreenButtonCommand.Command command = 1;
  void clear_command();
  ::ActionModule::GreenButtonCommand_Command command() const;
  void set_command(::ActionModule::GreenButtonCommand_Command value);
  private:
  ::ActionModule::GreenButtonCommand_Command _internal_command() const;
  void _internal_set_command(::ActionModule::GreenButtonCommand_Command value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.GreenButtonCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class RedButtonCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.RedButtonCommand) */ {
 public:
  inline RedButtonCommand() : RedButtonCommand(nullptr) {}
  ~RedButtonCommand() override;
  explicit constexpr RedButtonCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedButtonCommand(const RedButtonCommand& from);
  RedButtonCommand(RedButtonCommand&& from) noexcept
    : RedButtonCommand() {
    *this = ::std::move(from);
  }

  inline RedButtonCommand& operator=(const RedButtonCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedButtonCommand& operator=(RedButtonCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedButtonCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedButtonCommand* internal_default_instance() {
    return reinterpret_cast<const RedButtonCommand*>(
               &_RedButtonCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RedButtonCommand& a, RedButtonCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RedButtonCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedButtonCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedButtonCommand* New() const final {
    return new RedButtonCommand();
  }

  RedButtonCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedButtonCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedButtonCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RedButtonCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedButtonCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.RedButtonCommand";
  }
  protected:
  explicit RedButtonCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RedButtonCommand_Command Command;
  static constexpr Command PRESS =
    RedButtonCommand_Command_PRESS;
  static inline bool Command_IsValid(int value) {
    return RedButtonCommand_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    RedButtonCommand_Command_Command_MIN;
  static constexpr Command Command_MAX =
    RedButtonCommand_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    RedButtonCommand_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return RedButtonCommand_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return RedButtonCommand_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return RedButtonCommand_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // .ActionModule.RedButtonCommand.Command command = 1;
  void clear_command();
  ::ActionModule::RedButtonCommand_Command command() const;
  void set_command(::ActionModule::RedButtonCommand_Command value);
  private:
  ::ActionModule::RedButtonCommand_Command _internal_command() const;
  void _internal_set_command(::ActionModule::RedButtonCommand_Command value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.RedButtonCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class WatchdogCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.WatchdogCommand) */ {
 public:
  inline WatchdogCommand() : WatchdogCommand(nullptr) {}
  ~WatchdogCommand() override;
  explicit constexpr WatchdogCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchdogCommand(const WatchdogCommand& from);
  WatchdogCommand(WatchdogCommand&& from) noexcept
    : WatchdogCommand() {
    *this = ::std::move(from);
  }

  inline WatchdogCommand& operator=(const WatchdogCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchdogCommand& operator=(WatchdogCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchdogCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchdogCommand* internal_default_instance() {
    return reinterpret_cast<const WatchdogCommand*>(
               &_WatchdogCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WatchdogCommand& a, WatchdogCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchdogCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchdogCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchdogCommand* New() const final {
    return new WatchdogCommand();
  }

  WatchdogCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchdogCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchdogCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchdogCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchdogCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.WatchdogCommand";
  }
  protected:
  explicit WatchdogCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WatchdogCommand_Command Command;
  static constexpr Command RESET =
    WatchdogCommand_Command_RESET;
  static inline bool Command_IsValid(int value) {
    return WatchdogCommand_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    WatchdogCommand_Command_Command_MIN;
  static constexpr Command Command_MAX =
    WatchdogCommand_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    WatchdogCommand_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return WatchdogCommand_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return WatchdogCommand_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return WatchdogCommand_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // .ActionModule.WatchdogCommand.Command command = 1;
  void clear_command();
  ::ActionModule::WatchdogCommand_Command command() const;
  void set_command(::ActionModule::WatchdogCommand_Command value);
  private:
  ::ActionModule::WatchdogCommand_Command _internal_command() const;
  void _internal_set_command(::ActionModule::WatchdogCommand_Command value);
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.WatchdogCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class SystemLoggerError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.SystemLoggerError) */ {
 public:
  inline SystemLoggerError() : SystemLoggerError(nullptr) {}
  ~SystemLoggerError() override;
  explicit constexpr SystemLoggerError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemLoggerError(const SystemLoggerError& from);
  SystemLoggerError(SystemLoggerError&& from) noexcept
    : SystemLoggerError() {
    *this = ::std::move(from);
  }

  inline SystemLoggerError& operator=(const SystemLoggerError& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemLoggerError& operator=(SystemLoggerError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemLoggerError& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemLoggerError* internal_default_instance() {
    return reinterpret_cast<const SystemLoggerError*>(
               &_SystemLoggerError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SystemLoggerError& a, SystemLoggerError& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemLoggerError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemLoggerError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemLoggerError* New() const final {
    return new SystemLoggerError();
  }

  SystemLoggerError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemLoggerError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemLoggerError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SystemLoggerError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemLoggerError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.SystemLoggerError";
  }
  protected:
  explicit SystemLoggerError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // string errorMessage = 1;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_MUST_USE_RESULT std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.SystemLoggerError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class GreenButtonError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.GreenButtonError) */ {
 public:
  inline GreenButtonError() : GreenButtonError(nullptr) {}
  ~GreenButtonError() override;
  explicit constexpr GreenButtonError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GreenButtonError(const GreenButtonError& from);
  GreenButtonError(GreenButtonError&& from) noexcept
    : GreenButtonError() {
    *this = ::std::move(from);
  }

  inline GreenButtonError& operator=(const GreenButtonError& from) {
    CopyFrom(from);
    return *this;
  }
  inline GreenButtonError& operator=(GreenButtonError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GreenButtonError& default_instance() {
    return *internal_default_instance();
  }
  static inline const GreenButtonError* internal_default_instance() {
    return reinterpret_cast<const GreenButtonError*>(
               &_GreenButtonError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GreenButtonError& a, GreenButtonError& b) {
    a.Swap(&b);
  }
  inline void Swap(GreenButtonError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GreenButtonError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GreenButtonError* New() const final {
    return new GreenButtonError();
  }

  GreenButtonError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GreenButtonError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GreenButtonError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GreenButtonError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreenButtonError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.GreenButtonError";
  }
  protected:
  explicit GreenButtonError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // string errorMessage = 1;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_MUST_USE_RESULT std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.GreenButtonError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class RedButtonError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.RedButtonError) */ {
 public:
  inline RedButtonError() : RedButtonError(nullptr) {}
  ~RedButtonError() override;
  explicit constexpr RedButtonError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedButtonError(const RedButtonError& from);
  RedButtonError(RedButtonError&& from) noexcept
    : RedButtonError() {
    *this = ::std::move(from);
  }

  inline RedButtonError& operator=(const RedButtonError& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedButtonError& operator=(RedButtonError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedButtonError& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedButtonError* internal_default_instance() {
    return reinterpret_cast<const RedButtonError*>(
               &_RedButtonError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RedButtonError& a, RedButtonError& b) {
    a.Swap(&b);
  }
  inline void Swap(RedButtonError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedButtonError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedButtonError* New() const final {
    return new RedButtonError();
  }

  RedButtonError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedButtonError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedButtonError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RedButtonError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedButtonError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.RedButtonError";
  }
  protected:
  explicit RedButtonError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // string errorMessage = 1;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_MUST_USE_RESULT std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.RedButtonError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// -------------------------------------------------------------------

class WatchdogError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionModule.WatchdogError) */ {
 public:
  inline WatchdogError() : WatchdogError(nullptr) {}
  ~WatchdogError() override;
  explicit constexpr WatchdogError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchdogError(const WatchdogError& from);
  WatchdogError(WatchdogError&& from) noexcept
    : WatchdogError() {
    *this = ::std::move(from);
  }

  inline WatchdogError& operator=(const WatchdogError& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchdogError& operator=(WatchdogError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchdogError& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchdogError* internal_default_instance() {
    return reinterpret_cast<const WatchdogError*>(
               &_WatchdogError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WatchdogError& a, WatchdogError& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchdogError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchdogError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchdogError* New() const final {
    return new WatchdogError();
  }

  WatchdogError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchdogError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchdogError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchdogError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchdogError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionModule.WatchdogError";
  }
  protected:
  explicit WatchdogError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // string errorMessage = 1;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_MUST_USE_RESULT std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // @@protoc_insertion_point(class_scope:ActionModule.WatchdogError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fActionModule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ActionStatus

// .ActionModule.Device device = 1;
inline bool ActionStatus::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool ActionStatus::has_device() const {
  return _internal_has_device();
}
inline void ActionStatus::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::ActionModule::Device& ActionStatus::_internal_device() const {
  const ::ActionModule::Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActionModule::Device&>(
      ::ActionModule::_Device_default_instance_);
}
inline const ::ActionModule::Device& ActionStatus::device() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionStatus.device)
  return _internal_device();
}
inline void ActionStatus::unsafe_arena_set_allocated_device(
    ::ActionModule::Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionStatus.device)
}
inline ::ActionModule::Device* ActionStatus::release_device() {
  
  ::ActionModule::Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActionModule::Device* ActionStatus::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionStatus.device)
  
  ::ActionModule::Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::ActionModule::Device* ActionStatus::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActionModule::Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::ActionModule::Device* ActionStatus::mutable_device() {
  ::ActionModule::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionStatus.device)
  return _msg;
}
inline void ActionStatus::set_allocated_device(::ActionModule::Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ActionModule::Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ActionModule.ActionStatus.device)
}

// .ActionModule.SystemLoggerStatus systemLoggerStatus = 2;
inline bool ActionStatus::_internal_has_systemloggerstatus() const {
  return DeviceStatusType_case() == kSystemLoggerStatus;
}
inline bool ActionStatus::has_systemloggerstatus() const {
  return _internal_has_systemloggerstatus();
}
inline void ActionStatus::set_has_systemloggerstatus() {
  _oneof_case_[0] = kSystemLoggerStatus;
}
inline void ActionStatus::clear_systemloggerstatus() {
  if (_internal_has_systemloggerstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceStatusType_.systemloggerstatus_;
    }
    clear_has_DeviceStatusType();
  }
}
inline ::ActionModule::SystemLoggerStatus* ActionStatus::release_systemloggerstatus() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionStatus.systemLoggerStatus)
  if (_internal_has_systemloggerstatus()) {
    clear_has_DeviceStatusType();
      ::ActionModule::SystemLoggerStatus* temp = DeviceStatusType_.systemloggerstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceStatusType_.systemloggerstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::SystemLoggerStatus& ActionStatus::_internal_systemloggerstatus() const {
  return _internal_has_systemloggerstatus()
      ? *DeviceStatusType_.systemloggerstatus_
      : reinterpret_cast< ::ActionModule::SystemLoggerStatus&>(::ActionModule::_SystemLoggerStatus_default_instance_);
}
inline const ::ActionModule::SystemLoggerStatus& ActionStatus::systemloggerstatus() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionStatus.systemLoggerStatus)
  return _internal_systemloggerstatus();
}
inline ::ActionModule::SystemLoggerStatus* ActionStatus::unsafe_arena_release_systemloggerstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionStatus.systemLoggerStatus)
  if (_internal_has_systemloggerstatus()) {
    clear_has_DeviceStatusType();
    ::ActionModule::SystemLoggerStatus* temp = DeviceStatusType_.systemloggerstatus_;
    DeviceStatusType_.systemloggerstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionStatus::unsafe_arena_set_allocated_systemloggerstatus(::ActionModule::SystemLoggerStatus* systemloggerstatus) {
  clear_DeviceStatusType();
  if (systemloggerstatus) {
    set_has_systemloggerstatus();
    DeviceStatusType_.systemloggerstatus_ = systemloggerstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionStatus.systemLoggerStatus)
}
inline ::ActionModule::SystemLoggerStatus* ActionStatus::_internal_mutable_systemloggerstatus() {
  if (!_internal_has_systemloggerstatus()) {
    clear_DeviceStatusType();
    set_has_systemloggerstatus();
    DeviceStatusType_.systemloggerstatus_ = CreateMaybeMessage< ::ActionModule::SystemLoggerStatus >(GetArenaForAllocation());
  }
  return DeviceStatusType_.systemloggerstatus_;
}
inline ::ActionModule::SystemLoggerStatus* ActionStatus::mutable_systemloggerstatus() {
  ::ActionModule::SystemLoggerStatus* _msg = _internal_mutable_systemloggerstatus();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionStatus.systemLoggerStatus)
  return _msg;
}

// .ActionModule.GreenButtonStatus greenButtonStatus = 3;
inline bool ActionStatus::_internal_has_greenbuttonstatus() const {
  return DeviceStatusType_case() == kGreenButtonStatus;
}
inline bool ActionStatus::has_greenbuttonstatus() const {
  return _internal_has_greenbuttonstatus();
}
inline void ActionStatus::set_has_greenbuttonstatus() {
  _oneof_case_[0] = kGreenButtonStatus;
}
inline void ActionStatus::clear_greenbuttonstatus() {
  if (_internal_has_greenbuttonstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceStatusType_.greenbuttonstatus_;
    }
    clear_has_DeviceStatusType();
  }
}
inline ::ActionModule::GreenButtonStatus* ActionStatus::release_greenbuttonstatus() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionStatus.greenButtonStatus)
  if (_internal_has_greenbuttonstatus()) {
    clear_has_DeviceStatusType();
      ::ActionModule::GreenButtonStatus* temp = DeviceStatusType_.greenbuttonstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceStatusType_.greenbuttonstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::GreenButtonStatus& ActionStatus::_internal_greenbuttonstatus() const {
  return _internal_has_greenbuttonstatus()
      ? *DeviceStatusType_.greenbuttonstatus_
      : reinterpret_cast< ::ActionModule::GreenButtonStatus&>(::ActionModule::_GreenButtonStatus_default_instance_);
}
inline const ::ActionModule::GreenButtonStatus& ActionStatus::greenbuttonstatus() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionStatus.greenButtonStatus)
  return _internal_greenbuttonstatus();
}
inline ::ActionModule::GreenButtonStatus* ActionStatus::unsafe_arena_release_greenbuttonstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionStatus.greenButtonStatus)
  if (_internal_has_greenbuttonstatus()) {
    clear_has_DeviceStatusType();
    ::ActionModule::GreenButtonStatus* temp = DeviceStatusType_.greenbuttonstatus_;
    DeviceStatusType_.greenbuttonstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionStatus::unsafe_arena_set_allocated_greenbuttonstatus(::ActionModule::GreenButtonStatus* greenbuttonstatus) {
  clear_DeviceStatusType();
  if (greenbuttonstatus) {
    set_has_greenbuttonstatus();
    DeviceStatusType_.greenbuttonstatus_ = greenbuttonstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionStatus.greenButtonStatus)
}
inline ::ActionModule::GreenButtonStatus* ActionStatus::_internal_mutable_greenbuttonstatus() {
  if (!_internal_has_greenbuttonstatus()) {
    clear_DeviceStatusType();
    set_has_greenbuttonstatus();
    DeviceStatusType_.greenbuttonstatus_ = CreateMaybeMessage< ::ActionModule::GreenButtonStatus >(GetArenaForAllocation());
  }
  return DeviceStatusType_.greenbuttonstatus_;
}
inline ::ActionModule::GreenButtonStatus* ActionStatus::mutable_greenbuttonstatus() {
  ::ActionModule::GreenButtonStatus* _msg = _internal_mutable_greenbuttonstatus();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionStatus.greenButtonStatus)
  return _msg;
}

// .ActionModule.RedButtonStatus redButtonStatus = 4;
inline bool ActionStatus::_internal_has_redbuttonstatus() const {
  return DeviceStatusType_case() == kRedButtonStatus;
}
inline bool ActionStatus::has_redbuttonstatus() const {
  return _internal_has_redbuttonstatus();
}
inline void ActionStatus::set_has_redbuttonstatus() {
  _oneof_case_[0] = kRedButtonStatus;
}
inline void ActionStatus::clear_redbuttonstatus() {
  if (_internal_has_redbuttonstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceStatusType_.redbuttonstatus_;
    }
    clear_has_DeviceStatusType();
  }
}
inline ::ActionModule::RedButtonStatus* ActionStatus::release_redbuttonstatus() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionStatus.redButtonStatus)
  if (_internal_has_redbuttonstatus()) {
    clear_has_DeviceStatusType();
      ::ActionModule::RedButtonStatus* temp = DeviceStatusType_.redbuttonstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceStatusType_.redbuttonstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::RedButtonStatus& ActionStatus::_internal_redbuttonstatus() const {
  return _internal_has_redbuttonstatus()
      ? *DeviceStatusType_.redbuttonstatus_
      : reinterpret_cast< ::ActionModule::RedButtonStatus&>(::ActionModule::_RedButtonStatus_default_instance_);
}
inline const ::ActionModule::RedButtonStatus& ActionStatus::redbuttonstatus() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionStatus.redButtonStatus)
  return _internal_redbuttonstatus();
}
inline ::ActionModule::RedButtonStatus* ActionStatus::unsafe_arena_release_redbuttonstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionStatus.redButtonStatus)
  if (_internal_has_redbuttonstatus()) {
    clear_has_DeviceStatusType();
    ::ActionModule::RedButtonStatus* temp = DeviceStatusType_.redbuttonstatus_;
    DeviceStatusType_.redbuttonstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionStatus::unsafe_arena_set_allocated_redbuttonstatus(::ActionModule::RedButtonStatus* redbuttonstatus) {
  clear_DeviceStatusType();
  if (redbuttonstatus) {
    set_has_redbuttonstatus();
    DeviceStatusType_.redbuttonstatus_ = redbuttonstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionStatus.redButtonStatus)
}
inline ::ActionModule::RedButtonStatus* ActionStatus::_internal_mutable_redbuttonstatus() {
  if (!_internal_has_redbuttonstatus()) {
    clear_DeviceStatusType();
    set_has_redbuttonstatus();
    DeviceStatusType_.redbuttonstatus_ = CreateMaybeMessage< ::ActionModule::RedButtonStatus >(GetArenaForAllocation());
  }
  return DeviceStatusType_.redbuttonstatus_;
}
inline ::ActionModule::RedButtonStatus* ActionStatus::mutable_redbuttonstatus() {
  ::ActionModule::RedButtonStatus* _msg = _internal_mutable_redbuttonstatus();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionStatus.redButtonStatus)
  return _msg;
}

// .ActionModule.WatchdogStatus watchdogStatus = 5;
inline bool ActionStatus::_internal_has_watchdogstatus() const {
  return DeviceStatusType_case() == kWatchdogStatus;
}
inline bool ActionStatus::has_watchdogstatus() const {
  return _internal_has_watchdogstatus();
}
inline void ActionStatus::set_has_watchdogstatus() {
  _oneof_case_[0] = kWatchdogStatus;
}
inline void ActionStatus::clear_watchdogstatus() {
  if (_internal_has_watchdogstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceStatusType_.watchdogstatus_;
    }
    clear_has_DeviceStatusType();
  }
}
inline ::ActionModule::WatchdogStatus* ActionStatus::release_watchdogstatus() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionStatus.watchdogStatus)
  if (_internal_has_watchdogstatus()) {
    clear_has_DeviceStatusType();
      ::ActionModule::WatchdogStatus* temp = DeviceStatusType_.watchdogstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceStatusType_.watchdogstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::WatchdogStatus& ActionStatus::_internal_watchdogstatus() const {
  return _internal_has_watchdogstatus()
      ? *DeviceStatusType_.watchdogstatus_
      : reinterpret_cast< ::ActionModule::WatchdogStatus&>(::ActionModule::_WatchdogStatus_default_instance_);
}
inline const ::ActionModule::WatchdogStatus& ActionStatus::watchdogstatus() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionStatus.watchdogStatus)
  return _internal_watchdogstatus();
}
inline ::ActionModule::WatchdogStatus* ActionStatus::unsafe_arena_release_watchdogstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionStatus.watchdogStatus)
  if (_internal_has_watchdogstatus()) {
    clear_has_DeviceStatusType();
    ::ActionModule::WatchdogStatus* temp = DeviceStatusType_.watchdogstatus_;
    DeviceStatusType_.watchdogstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionStatus::unsafe_arena_set_allocated_watchdogstatus(::ActionModule::WatchdogStatus* watchdogstatus) {
  clear_DeviceStatusType();
  if (watchdogstatus) {
    set_has_watchdogstatus();
    DeviceStatusType_.watchdogstatus_ = watchdogstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionStatus.watchdogStatus)
}
inline ::ActionModule::WatchdogStatus* ActionStatus::_internal_mutable_watchdogstatus() {
  if (!_internal_has_watchdogstatus()) {
    clear_DeviceStatusType();
    set_has_watchdogstatus();
    DeviceStatusType_.watchdogstatus_ = CreateMaybeMessage< ::ActionModule::WatchdogStatus >(GetArenaForAllocation());
  }
  return DeviceStatusType_.watchdogstatus_;
}
inline ::ActionModule::WatchdogStatus* ActionStatus::mutable_watchdogstatus() {
  ::ActionModule::WatchdogStatus* _msg = _internal_mutable_watchdogstatus();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionStatus.watchdogStatus)
  return _msg;
}

inline bool ActionStatus::has_DeviceStatusType() const {
  return DeviceStatusType_case() != DEVICESTATUSTYPE_NOT_SET;
}
inline void ActionStatus::clear_has_DeviceStatusType() {
  _oneof_case_[0] = DEVICESTATUSTYPE_NOT_SET;
}
inline ActionStatus::DeviceStatusTypeCase ActionStatus::DeviceStatusType_case() const {
  return ActionStatus::DeviceStatusTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionCommand

// .ActionModule.Device device = 1;
inline bool ActionCommand::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool ActionCommand::has_device() const {
  return _internal_has_device();
}
inline void ActionCommand::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::ActionModule::Device& ActionCommand::_internal_device() const {
  const ::ActionModule::Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActionModule::Device&>(
      ::ActionModule::_Device_default_instance_);
}
inline const ::ActionModule::Device& ActionCommand::device() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionCommand.device)
  return _internal_device();
}
inline void ActionCommand::unsafe_arena_set_allocated_device(
    ::ActionModule::Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionCommand.device)
}
inline ::ActionModule::Device* ActionCommand::release_device() {
  
  ::ActionModule::Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActionModule::Device* ActionCommand::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionCommand.device)
  
  ::ActionModule::Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::ActionModule::Device* ActionCommand::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActionModule::Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::ActionModule::Device* ActionCommand::mutable_device() {
  ::ActionModule::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionCommand.device)
  return _msg;
}
inline void ActionCommand::set_allocated_device(::ActionModule::Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ActionModule::Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ActionModule.ActionCommand.device)
}

// .ActionModule.GreenButtonCommand greenButtonCommand = 2;
inline bool ActionCommand::_internal_has_greenbuttoncommand() const {
  return DeviceCommandType_case() == kGreenButtonCommand;
}
inline bool ActionCommand::has_greenbuttoncommand() const {
  return _internal_has_greenbuttoncommand();
}
inline void ActionCommand::set_has_greenbuttoncommand() {
  _oneof_case_[0] = kGreenButtonCommand;
}
inline void ActionCommand::clear_greenbuttoncommand() {
  if (_internal_has_greenbuttoncommand()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceCommandType_.greenbuttoncommand_;
    }
    clear_has_DeviceCommandType();
  }
}
inline ::ActionModule::GreenButtonCommand* ActionCommand::release_greenbuttoncommand() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionCommand.greenButtonCommand)
  if (_internal_has_greenbuttoncommand()) {
    clear_has_DeviceCommandType();
      ::ActionModule::GreenButtonCommand* temp = DeviceCommandType_.greenbuttoncommand_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceCommandType_.greenbuttoncommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::GreenButtonCommand& ActionCommand::_internal_greenbuttoncommand() const {
  return _internal_has_greenbuttoncommand()
      ? *DeviceCommandType_.greenbuttoncommand_
      : reinterpret_cast< ::ActionModule::GreenButtonCommand&>(::ActionModule::_GreenButtonCommand_default_instance_);
}
inline const ::ActionModule::GreenButtonCommand& ActionCommand::greenbuttoncommand() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionCommand.greenButtonCommand)
  return _internal_greenbuttoncommand();
}
inline ::ActionModule::GreenButtonCommand* ActionCommand::unsafe_arena_release_greenbuttoncommand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionCommand.greenButtonCommand)
  if (_internal_has_greenbuttoncommand()) {
    clear_has_DeviceCommandType();
    ::ActionModule::GreenButtonCommand* temp = DeviceCommandType_.greenbuttoncommand_;
    DeviceCommandType_.greenbuttoncommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionCommand::unsafe_arena_set_allocated_greenbuttoncommand(::ActionModule::GreenButtonCommand* greenbuttoncommand) {
  clear_DeviceCommandType();
  if (greenbuttoncommand) {
    set_has_greenbuttoncommand();
    DeviceCommandType_.greenbuttoncommand_ = greenbuttoncommand;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionCommand.greenButtonCommand)
}
inline ::ActionModule::GreenButtonCommand* ActionCommand::_internal_mutable_greenbuttoncommand() {
  if (!_internal_has_greenbuttoncommand()) {
    clear_DeviceCommandType();
    set_has_greenbuttoncommand();
    DeviceCommandType_.greenbuttoncommand_ = CreateMaybeMessage< ::ActionModule::GreenButtonCommand >(GetArenaForAllocation());
  }
  return DeviceCommandType_.greenbuttoncommand_;
}
inline ::ActionModule::GreenButtonCommand* ActionCommand::mutable_greenbuttoncommand() {
  ::ActionModule::GreenButtonCommand* _msg = _internal_mutable_greenbuttoncommand();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionCommand.greenButtonCommand)
  return _msg;
}

// .ActionModule.RedButtonCommand redButtonCommand = 3;
inline bool ActionCommand::_internal_has_redbuttoncommand() const {
  return DeviceCommandType_case() == kRedButtonCommand;
}
inline bool ActionCommand::has_redbuttoncommand() const {
  return _internal_has_redbuttoncommand();
}
inline void ActionCommand::set_has_redbuttoncommand() {
  _oneof_case_[0] = kRedButtonCommand;
}
inline void ActionCommand::clear_redbuttoncommand() {
  if (_internal_has_redbuttoncommand()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceCommandType_.redbuttoncommand_;
    }
    clear_has_DeviceCommandType();
  }
}
inline ::ActionModule::RedButtonCommand* ActionCommand::release_redbuttoncommand() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionCommand.redButtonCommand)
  if (_internal_has_redbuttoncommand()) {
    clear_has_DeviceCommandType();
      ::ActionModule::RedButtonCommand* temp = DeviceCommandType_.redbuttoncommand_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceCommandType_.redbuttoncommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::RedButtonCommand& ActionCommand::_internal_redbuttoncommand() const {
  return _internal_has_redbuttoncommand()
      ? *DeviceCommandType_.redbuttoncommand_
      : reinterpret_cast< ::ActionModule::RedButtonCommand&>(::ActionModule::_RedButtonCommand_default_instance_);
}
inline const ::ActionModule::RedButtonCommand& ActionCommand::redbuttoncommand() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionCommand.redButtonCommand)
  return _internal_redbuttoncommand();
}
inline ::ActionModule::RedButtonCommand* ActionCommand::unsafe_arena_release_redbuttoncommand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionCommand.redButtonCommand)
  if (_internal_has_redbuttoncommand()) {
    clear_has_DeviceCommandType();
    ::ActionModule::RedButtonCommand* temp = DeviceCommandType_.redbuttoncommand_;
    DeviceCommandType_.redbuttoncommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionCommand::unsafe_arena_set_allocated_redbuttoncommand(::ActionModule::RedButtonCommand* redbuttoncommand) {
  clear_DeviceCommandType();
  if (redbuttoncommand) {
    set_has_redbuttoncommand();
    DeviceCommandType_.redbuttoncommand_ = redbuttoncommand;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionCommand.redButtonCommand)
}
inline ::ActionModule::RedButtonCommand* ActionCommand::_internal_mutable_redbuttoncommand() {
  if (!_internal_has_redbuttoncommand()) {
    clear_DeviceCommandType();
    set_has_redbuttoncommand();
    DeviceCommandType_.redbuttoncommand_ = CreateMaybeMessage< ::ActionModule::RedButtonCommand >(GetArenaForAllocation());
  }
  return DeviceCommandType_.redbuttoncommand_;
}
inline ::ActionModule::RedButtonCommand* ActionCommand::mutable_redbuttoncommand() {
  ::ActionModule::RedButtonCommand* _msg = _internal_mutable_redbuttoncommand();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionCommand.redButtonCommand)
  return _msg;
}

// .ActionModule.WatchdogCommand watchdogCommand = 4;
inline bool ActionCommand::_internal_has_watchdogcommand() const {
  return DeviceCommandType_case() == kWatchdogCommand;
}
inline bool ActionCommand::has_watchdogcommand() const {
  return _internal_has_watchdogcommand();
}
inline void ActionCommand::set_has_watchdogcommand() {
  _oneof_case_[0] = kWatchdogCommand;
}
inline void ActionCommand::clear_watchdogcommand() {
  if (_internal_has_watchdogcommand()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceCommandType_.watchdogcommand_;
    }
    clear_has_DeviceCommandType();
  }
}
inline ::ActionModule::WatchdogCommand* ActionCommand::release_watchdogcommand() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionCommand.watchdogCommand)
  if (_internal_has_watchdogcommand()) {
    clear_has_DeviceCommandType();
      ::ActionModule::WatchdogCommand* temp = DeviceCommandType_.watchdogcommand_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceCommandType_.watchdogcommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::WatchdogCommand& ActionCommand::_internal_watchdogcommand() const {
  return _internal_has_watchdogcommand()
      ? *DeviceCommandType_.watchdogcommand_
      : reinterpret_cast< ::ActionModule::WatchdogCommand&>(::ActionModule::_WatchdogCommand_default_instance_);
}
inline const ::ActionModule::WatchdogCommand& ActionCommand::watchdogcommand() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionCommand.watchdogCommand)
  return _internal_watchdogcommand();
}
inline ::ActionModule::WatchdogCommand* ActionCommand::unsafe_arena_release_watchdogcommand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionCommand.watchdogCommand)
  if (_internal_has_watchdogcommand()) {
    clear_has_DeviceCommandType();
    ::ActionModule::WatchdogCommand* temp = DeviceCommandType_.watchdogcommand_;
    DeviceCommandType_.watchdogcommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionCommand::unsafe_arena_set_allocated_watchdogcommand(::ActionModule::WatchdogCommand* watchdogcommand) {
  clear_DeviceCommandType();
  if (watchdogcommand) {
    set_has_watchdogcommand();
    DeviceCommandType_.watchdogcommand_ = watchdogcommand;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionCommand.watchdogCommand)
}
inline ::ActionModule::WatchdogCommand* ActionCommand::_internal_mutable_watchdogcommand() {
  if (!_internal_has_watchdogcommand()) {
    clear_DeviceCommandType();
    set_has_watchdogcommand();
    DeviceCommandType_.watchdogcommand_ = CreateMaybeMessage< ::ActionModule::WatchdogCommand >(GetArenaForAllocation());
  }
  return DeviceCommandType_.watchdogcommand_;
}
inline ::ActionModule::WatchdogCommand* ActionCommand::mutable_watchdogcommand() {
  ::ActionModule::WatchdogCommand* _msg = _internal_mutable_watchdogcommand();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionCommand.watchdogCommand)
  return _msg;
}

// .ActionModule.SystemLoggerCommand systemLoggerCommand = 5;
inline bool ActionCommand::_internal_has_systemloggercommand() const {
  return DeviceCommandType_case() == kSystemLoggerCommand;
}
inline bool ActionCommand::has_systemloggercommand() const {
  return _internal_has_systemloggercommand();
}
inline void ActionCommand::set_has_systemloggercommand() {
  _oneof_case_[0] = kSystemLoggerCommand;
}
inline void ActionCommand::clear_systemloggercommand() {
  if (_internal_has_systemloggercommand()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceCommandType_.systemloggercommand_;
    }
    clear_has_DeviceCommandType();
  }
}
inline ::ActionModule::SystemLoggerCommand* ActionCommand::release_systemloggercommand() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionCommand.systemLoggerCommand)
  if (_internal_has_systemloggercommand()) {
    clear_has_DeviceCommandType();
      ::ActionModule::SystemLoggerCommand* temp = DeviceCommandType_.systemloggercommand_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceCommandType_.systemloggercommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::SystemLoggerCommand& ActionCommand::_internal_systemloggercommand() const {
  return _internal_has_systemloggercommand()
      ? *DeviceCommandType_.systemloggercommand_
      : reinterpret_cast< ::ActionModule::SystemLoggerCommand&>(::ActionModule::_SystemLoggerCommand_default_instance_);
}
inline const ::ActionModule::SystemLoggerCommand& ActionCommand::systemloggercommand() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionCommand.systemLoggerCommand)
  return _internal_systemloggercommand();
}
inline ::ActionModule::SystemLoggerCommand* ActionCommand::unsafe_arena_release_systemloggercommand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionCommand.systemLoggerCommand)
  if (_internal_has_systemloggercommand()) {
    clear_has_DeviceCommandType();
    ::ActionModule::SystemLoggerCommand* temp = DeviceCommandType_.systemloggercommand_;
    DeviceCommandType_.systemloggercommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionCommand::unsafe_arena_set_allocated_systemloggercommand(::ActionModule::SystemLoggerCommand* systemloggercommand) {
  clear_DeviceCommandType();
  if (systemloggercommand) {
    set_has_systemloggercommand();
    DeviceCommandType_.systemloggercommand_ = systemloggercommand;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionCommand.systemLoggerCommand)
}
inline ::ActionModule::SystemLoggerCommand* ActionCommand::_internal_mutable_systemloggercommand() {
  if (!_internal_has_systemloggercommand()) {
    clear_DeviceCommandType();
    set_has_systemloggercommand();
    DeviceCommandType_.systemloggercommand_ = CreateMaybeMessage< ::ActionModule::SystemLoggerCommand >(GetArenaForAllocation());
  }
  return DeviceCommandType_.systemloggercommand_;
}
inline ::ActionModule::SystemLoggerCommand* ActionCommand::mutable_systemloggercommand() {
  ::ActionModule::SystemLoggerCommand* _msg = _internal_mutable_systemloggercommand();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionCommand.systemLoggerCommand)
  return _msg;
}

inline bool ActionCommand::has_DeviceCommandType() const {
  return DeviceCommandType_case() != DEVICECOMMANDTYPE_NOT_SET;
}
inline void ActionCommand::clear_has_DeviceCommandType() {
  _oneof_case_[0] = DEVICECOMMANDTYPE_NOT_SET;
}
inline ActionCommand::DeviceCommandTypeCase ActionCommand::DeviceCommandType_case() const {
  return ActionCommand::DeviceCommandTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionError

// .ActionModule.Device device = 1;
inline bool ActionError::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool ActionError::has_device() const {
  return _internal_has_device();
}
inline void ActionError::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::ActionModule::Device& ActionError::_internal_device() const {
  const ::ActionModule::Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActionModule::Device&>(
      ::ActionModule::_Device_default_instance_);
}
inline const ::ActionModule::Device& ActionError::device() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionError.device)
  return _internal_device();
}
inline void ActionError::unsafe_arena_set_allocated_device(
    ::ActionModule::Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionError.device)
}
inline ::ActionModule::Device* ActionError::release_device() {
  
  ::ActionModule::Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActionModule::Device* ActionError::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionError.device)
  
  ::ActionModule::Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::ActionModule::Device* ActionError::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActionModule::Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::ActionModule::Device* ActionError::mutable_device() {
  ::ActionModule::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionError.device)
  return _msg;
}
inline void ActionError::set_allocated_device(::ActionModule::Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ActionModule::Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ActionModule.ActionError.device)
}

// .ActionModule.ActionError.Type type = 2;
inline void ActionError::clear_type() {
  type_ = 0;
}
inline ::ActionModule::ActionError_Type ActionError::_internal_type() const {
  return static_cast< ::ActionModule::ActionError_Type >(type_);
}
inline ::ActionModule::ActionError_Type ActionError::type() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionError.type)
  return _internal_type();
}
inline void ActionError::_internal_set_type(::ActionModule::ActionError_Type value) {
  
  type_ = value;
}
inline void ActionError::set_type(::ActionModule::ActionError_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ActionModule.ActionError.type)
}

// .ActionModule.GreenButtonError greenButtonError = 3;
inline bool ActionError::_internal_has_greenbuttonerror() const {
  return DeviceErrorType_case() == kGreenButtonError;
}
inline bool ActionError::has_greenbuttonerror() const {
  return _internal_has_greenbuttonerror();
}
inline void ActionError::set_has_greenbuttonerror() {
  _oneof_case_[0] = kGreenButtonError;
}
inline void ActionError::clear_greenbuttonerror() {
  if (_internal_has_greenbuttonerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceErrorType_.greenbuttonerror_;
    }
    clear_has_DeviceErrorType();
  }
}
inline ::ActionModule::GreenButtonError* ActionError::release_greenbuttonerror() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionError.greenButtonError)
  if (_internal_has_greenbuttonerror()) {
    clear_has_DeviceErrorType();
      ::ActionModule::GreenButtonError* temp = DeviceErrorType_.greenbuttonerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceErrorType_.greenbuttonerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::GreenButtonError& ActionError::_internal_greenbuttonerror() const {
  return _internal_has_greenbuttonerror()
      ? *DeviceErrorType_.greenbuttonerror_
      : reinterpret_cast< ::ActionModule::GreenButtonError&>(::ActionModule::_GreenButtonError_default_instance_);
}
inline const ::ActionModule::GreenButtonError& ActionError::greenbuttonerror() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionError.greenButtonError)
  return _internal_greenbuttonerror();
}
inline ::ActionModule::GreenButtonError* ActionError::unsafe_arena_release_greenbuttonerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionError.greenButtonError)
  if (_internal_has_greenbuttonerror()) {
    clear_has_DeviceErrorType();
    ::ActionModule::GreenButtonError* temp = DeviceErrorType_.greenbuttonerror_;
    DeviceErrorType_.greenbuttonerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionError::unsafe_arena_set_allocated_greenbuttonerror(::ActionModule::GreenButtonError* greenbuttonerror) {
  clear_DeviceErrorType();
  if (greenbuttonerror) {
    set_has_greenbuttonerror();
    DeviceErrorType_.greenbuttonerror_ = greenbuttonerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionError.greenButtonError)
}
inline ::ActionModule::GreenButtonError* ActionError::_internal_mutable_greenbuttonerror() {
  if (!_internal_has_greenbuttonerror()) {
    clear_DeviceErrorType();
    set_has_greenbuttonerror();
    DeviceErrorType_.greenbuttonerror_ = CreateMaybeMessage< ::ActionModule::GreenButtonError >(GetArenaForAllocation());
  }
  return DeviceErrorType_.greenbuttonerror_;
}
inline ::ActionModule::GreenButtonError* ActionError::mutable_greenbuttonerror() {
  ::ActionModule::GreenButtonError* _msg = _internal_mutable_greenbuttonerror();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionError.greenButtonError)
  return _msg;
}

// .ActionModule.RedButtonError redButtonError = 4;
inline bool ActionError::_internal_has_redbuttonerror() const {
  return DeviceErrorType_case() == kRedButtonError;
}
inline bool ActionError::has_redbuttonerror() const {
  return _internal_has_redbuttonerror();
}
inline void ActionError::set_has_redbuttonerror() {
  _oneof_case_[0] = kRedButtonError;
}
inline void ActionError::clear_redbuttonerror() {
  if (_internal_has_redbuttonerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceErrorType_.redbuttonerror_;
    }
    clear_has_DeviceErrorType();
  }
}
inline ::ActionModule::RedButtonError* ActionError::release_redbuttonerror() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionError.redButtonError)
  if (_internal_has_redbuttonerror()) {
    clear_has_DeviceErrorType();
      ::ActionModule::RedButtonError* temp = DeviceErrorType_.redbuttonerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceErrorType_.redbuttonerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::RedButtonError& ActionError::_internal_redbuttonerror() const {
  return _internal_has_redbuttonerror()
      ? *DeviceErrorType_.redbuttonerror_
      : reinterpret_cast< ::ActionModule::RedButtonError&>(::ActionModule::_RedButtonError_default_instance_);
}
inline const ::ActionModule::RedButtonError& ActionError::redbuttonerror() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionError.redButtonError)
  return _internal_redbuttonerror();
}
inline ::ActionModule::RedButtonError* ActionError::unsafe_arena_release_redbuttonerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionError.redButtonError)
  if (_internal_has_redbuttonerror()) {
    clear_has_DeviceErrorType();
    ::ActionModule::RedButtonError* temp = DeviceErrorType_.redbuttonerror_;
    DeviceErrorType_.redbuttonerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionError::unsafe_arena_set_allocated_redbuttonerror(::ActionModule::RedButtonError* redbuttonerror) {
  clear_DeviceErrorType();
  if (redbuttonerror) {
    set_has_redbuttonerror();
    DeviceErrorType_.redbuttonerror_ = redbuttonerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionError.redButtonError)
}
inline ::ActionModule::RedButtonError* ActionError::_internal_mutable_redbuttonerror() {
  if (!_internal_has_redbuttonerror()) {
    clear_DeviceErrorType();
    set_has_redbuttonerror();
    DeviceErrorType_.redbuttonerror_ = CreateMaybeMessage< ::ActionModule::RedButtonError >(GetArenaForAllocation());
  }
  return DeviceErrorType_.redbuttonerror_;
}
inline ::ActionModule::RedButtonError* ActionError::mutable_redbuttonerror() {
  ::ActionModule::RedButtonError* _msg = _internal_mutable_redbuttonerror();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionError.redButtonError)
  return _msg;
}

// .ActionModule.WatchdogError watchdogError = 5;
inline bool ActionError::_internal_has_watchdogerror() const {
  return DeviceErrorType_case() == kWatchdogError;
}
inline bool ActionError::has_watchdogerror() const {
  return _internal_has_watchdogerror();
}
inline void ActionError::set_has_watchdogerror() {
  _oneof_case_[0] = kWatchdogError;
}
inline void ActionError::clear_watchdogerror() {
  if (_internal_has_watchdogerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceErrorType_.watchdogerror_;
    }
    clear_has_DeviceErrorType();
  }
}
inline ::ActionModule::WatchdogError* ActionError::release_watchdogerror() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionError.watchdogError)
  if (_internal_has_watchdogerror()) {
    clear_has_DeviceErrorType();
      ::ActionModule::WatchdogError* temp = DeviceErrorType_.watchdogerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceErrorType_.watchdogerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::WatchdogError& ActionError::_internal_watchdogerror() const {
  return _internal_has_watchdogerror()
      ? *DeviceErrorType_.watchdogerror_
      : reinterpret_cast< ::ActionModule::WatchdogError&>(::ActionModule::_WatchdogError_default_instance_);
}
inline const ::ActionModule::WatchdogError& ActionError::watchdogerror() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionError.watchdogError)
  return _internal_watchdogerror();
}
inline ::ActionModule::WatchdogError* ActionError::unsafe_arena_release_watchdogerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionError.watchdogError)
  if (_internal_has_watchdogerror()) {
    clear_has_DeviceErrorType();
    ::ActionModule::WatchdogError* temp = DeviceErrorType_.watchdogerror_;
    DeviceErrorType_.watchdogerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionError::unsafe_arena_set_allocated_watchdogerror(::ActionModule::WatchdogError* watchdogerror) {
  clear_DeviceErrorType();
  if (watchdogerror) {
    set_has_watchdogerror();
    DeviceErrorType_.watchdogerror_ = watchdogerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionError.watchdogError)
}
inline ::ActionModule::WatchdogError* ActionError::_internal_mutable_watchdogerror() {
  if (!_internal_has_watchdogerror()) {
    clear_DeviceErrorType();
    set_has_watchdogerror();
    DeviceErrorType_.watchdogerror_ = CreateMaybeMessage< ::ActionModule::WatchdogError >(GetArenaForAllocation());
  }
  return DeviceErrorType_.watchdogerror_;
}
inline ::ActionModule::WatchdogError* ActionError::mutable_watchdogerror() {
  ::ActionModule::WatchdogError* _msg = _internal_mutable_watchdogerror();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionError.watchdogError)
  return _msg;
}

// .ActionModule.SystemLoggerError systemLoggerError = 6;
inline bool ActionError::_internal_has_systemloggererror() const {
  return DeviceErrorType_case() == kSystemLoggerError;
}
inline bool ActionError::has_systemloggererror() const {
  return _internal_has_systemloggererror();
}
inline void ActionError::set_has_systemloggererror() {
  _oneof_case_[0] = kSystemLoggerError;
}
inline void ActionError::clear_systemloggererror() {
  if (_internal_has_systemloggererror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceErrorType_.systemloggererror_;
    }
    clear_has_DeviceErrorType();
  }
}
inline ::ActionModule::SystemLoggerError* ActionError::release_systemloggererror() {
  // @@protoc_insertion_point(field_release:ActionModule.ActionError.systemLoggerError)
  if (_internal_has_systemloggererror()) {
    clear_has_DeviceErrorType();
      ::ActionModule::SystemLoggerError* temp = DeviceErrorType_.systemloggererror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceErrorType_.systemloggererror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ActionModule::SystemLoggerError& ActionError::_internal_systemloggererror() const {
  return _internal_has_systemloggererror()
      ? *DeviceErrorType_.systemloggererror_
      : reinterpret_cast< ::ActionModule::SystemLoggerError&>(::ActionModule::_SystemLoggerError_default_instance_);
}
inline const ::ActionModule::SystemLoggerError& ActionError::systemloggererror() const {
  // @@protoc_insertion_point(field_get:ActionModule.ActionError.systemLoggerError)
  return _internal_systemloggererror();
}
inline ::ActionModule::SystemLoggerError* ActionError::unsafe_arena_release_systemloggererror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ActionModule.ActionError.systemLoggerError)
  if (_internal_has_systemloggererror()) {
    clear_has_DeviceErrorType();
    ::ActionModule::SystemLoggerError* temp = DeviceErrorType_.systemloggererror_;
    DeviceErrorType_.systemloggererror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionError::unsafe_arena_set_allocated_systemloggererror(::ActionModule::SystemLoggerError* systemloggererror) {
  clear_DeviceErrorType();
  if (systemloggererror) {
    set_has_systemloggererror();
    DeviceErrorType_.systemloggererror_ = systemloggererror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ActionModule.ActionError.systemLoggerError)
}
inline ::ActionModule::SystemLoggerError* ActionError::_internal_mutable_systemloggererror() {
  if (!_internal_has_systemloggererror()) {
    clear_DeviceErrorType();
    set_has_systemloggererror();
    DeviceErrorType_.systemloggererror_ = CreateMaybeMessage< ::ActionModule::SystemLoggerError >(GetArenaForAllocation());
  }
  return DeviceErrorType_.systemloggererror_;
}
inline ::ActionModule::SystemLoggerError* ActionError::mutable_systemloggererror() {
  ::ActionModule::SystemLoggerError* _msg = _internal_mutable_systemloggererror();
  // @@protoc_insertion_point(field_mutable:ActionModule.ActionError.systemLoggerError)
  return _msg;
}

inline bool ActionError::has_DeviceErrorType() const {
  return DeviceErrorType_case() != DEVICEERRORTYPE_NOT_SET;
}
inline void ActionError::clear_has_DeviceErrorType() {
  _oneof_case_[0] = DEVICEERRORTYPE_NOT_SET;
}
inline ActionError::DeviceErrorTypeCase ActionError::DeviceErrorType_case() const {
  return ActionError::DeviceErrorTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Device

// .ActionModule.Device.Module module = 1;
inline void Device::clear_module() {
  module_ = 0;
}
inline ::ActionModule::Device_Module Device::_internal_module() const {
  return static_cast< ::ActionModule::Device_Module >(module_);
}
inline ::ActionModule::Device_Module Device::module() const {
  // @@protoc_insertion_point(field_get:ActionModule.Device.module)
  return _internal_module();
}
inline void Device::_internal_set_module(::ActionModule::Device_Module value) {
  
  module_ = value;
}
inline void Device::set_module(::ActionModule::Device_Module value) {
  _internal_set_module(value);
  // @@protoc_insertion_point(field_set:ActionModule.Device.module)
}

// .ActionModule.Device.DeviceType deviceType = 2;
inline void Device::clear_devicetype() {
  devicetype_ = 0;
}
inline ::ActionModule::Device_DeviceType Device::_internal_devicetype() const {
  return static_cast< ::ActionModule::Device_DeviceType >(devicetype_);
}
inline ::ActionModule::Device_DeviceType Device::devicetype() const {
  // @@protoc_insertion_point(field_get:ActionModule.Device.deviceType)
  return _internal_devicetype();
}
inline void Device::_internal_set_devicetype(::ActionModule::Device_DeviceType value) {
  
  devicetype_ = value;
}
inline void Device::set_devicetype(::ActionModule::Device_DeviceType value) {
  _internal_set_devicetype(value);
  // @@protoc_insertion_point(field_set:ActionModule.Device.deviceType)
}

// string deviceName = 3;
inline void Device::clear_devicename() {
  devicename_.ClearToEmpty();
}
inline const std::string& Device::devicename() const {
  // @@protoc_insertion_point(field_get:ActionModule.Device.deviceName)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_devicename(ArgT0&& arg0, ArgT... args) {
 
 devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.Device.deviceName)
}
inline std::string* Device::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:ActionModule.Device.deviceName)
  return _s;
}
inline const std::string& Device::_internal_devicename() const {
  return devicename_.Get();
}
inline void Device::_internal_set_devicename(const std::string& value) {
  
  devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_devicename() {
  
  return devicename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_devicename() {
  // @@protoc_insertion_point(field_release:ActionModule.Device.deviceName)
  return devicename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    
  } else {
    
  }
  devicename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devicename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.Device.deviceName)
}

// -------------------------------------------------------------------

// SystemLoggerStatus

// string sourceDevice = 1;
inline void SystemLoggerStatus::clear_sourcedevice() {
  sourcedevice_.ClearToEmpty();
}
inline const std::string& SystemLoggerStatus::sourcedevice() const {
  // @@protoc_insertion_point(field_get:ActionModule.SystemLoggerStatus.sourceDevice)
  return _internal_sourcedevice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemLoggerStatus::set_sourcedevice(ArgT0&& arg0, ArgT... args) {
 
 sourcedevice_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.SystemLoggerStatus.sourceDevice)
}
inline std::string* SystemLoggerStatus::mutable_sourcedevice() {
  std::string* _s = _internal_mutable_sourcedevice();
  // @@protoc_insertion_point(field_mutable:ActionModule.SystemLoggerStatus.sourceDevice)
  return _s;
}
inline const std::string& SystemLoggerStatus::_internal_sourcedevice() const {
  return sourcedevice_.Get();
}
inline void SystemLoggerStatus::_internal_set_sourcedevice(const std::string& value) {
  
  sourcedevice_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemLoggerStatus::_internal_mutable_sourcedevice() {
  
  return sourcedevice_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemLoggerStatus::release_sourcedevice() {
  // @@protoc_insertion_point(field_release:ActionModule.SystemLoggerStatus.sourceDevice)
  return sourcedevice_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemLoggerStatus::set_allocated_sourcedevice(std::string* sourcedevice) {
  if (sourcedevice != nullptr) {
    
  } else {
    
  }
  sourcedevice_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcedevice,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.SystemLoggerStatus.sourceDevice)
}

// repeated string logs = 2;
inline int SystemLoggerStatus::_internal_logs_size() const {
  return logs_.size();
}
inline int SystemLoggerStatus::logs_size() const {
  return _internal_logs_size();
}
inline void SystemLoggerStatus::clear_logs() {
  logs_.Clear();
}
inline std::string* SystemLoggerStatus::add_logs() {
  std::string* _s = _internal_add_logs();
  // @@protoc_insertion_point(field_add_mutable:ActionModule.SystemLoggerStatus.logs)
  return _s;
}
inline const std::string& SystemLoggerStatus::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const std::string& SystemLoggerStatus::logs(int index) const {
  // @@protoc_insertion_point(field_get:ActionModule.SystemLoggerStatus.logs)
  return _internal_logs(index);
}
inline std::string* SystemLoggerStatus::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:ActionModule.SystemLoggerStatus.logs)
  return logs_.Mutable(index);
}
inline void SystemLoggerStatus::set_logs(int index, const std::string& value) {
  logs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ActionModule.SystemLoggerStatus.logs)
}
inline void SystemLoggerStatus::set_logs(int index, std::string&& value) {
  logs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ActionModule.SystemLoggerStatus.logs)
}
inline void SystemLoggerStatus::set_logs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ActionModule.SystemLoggerStatus.logs)
}
inline void SystemLoggerStatus::set_logs(int index, const char* value, size_t size) {
  logs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ActionModule.SystemLoggerStatus.logs)
}
inline std::string* SystemLoggerStatus::_internal_add_logs() {
  return logs_.Add();
}
inline void SystemLoggerStatus::add_logs(const std::string& value) {
  logs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ActionModule.SystemLoggerStatus.logs)
}
inline void SystemLoggerStatus::add_logs(std::string&& value) {
  logs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ActionModule.SystemLoggerStatus.logs)
}
inline void SystemLoggerStatus::add_logs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ActionModule.SystemLoggerStatus.logs)
}
inline void SystemLoggerStatus::add_logs(const char* value, size_t size) {
  logs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ActionModule.SystemLoggerStatus.logs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SystemLoggerStatus::logs() const {
  // @@protoc_insertion_point(field_list:ActionModule.SystemLoggerStatus.logs)
  return logs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SystemLoggerStatus::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:ActionModule.SystemLoggerStatus.logs)
  return &logs_;
}

// .ActionModule.SystemLoggerStatus.Verbosity verbosity = 3;
inline void SystemLoggerStatus::clear_verbosity() {
  verbosity_ = 0;
}
inline ::ActionModule::SystemLoggerStatus_Verbosity SystemLoggerStatus::_internal_verbosity() const {
  return static_cast< ::ActionModule::SystemLoggerStatus_Verbosity >(verbosity_);
}
inline ::ActionModule::SystemLoggerStatus_Verbosity SystemLoggerStatus::verbosity() const {
  // @@protoc_insertion_point(field_get:ActionModule.SystemLoggerStatus.verbosity)
  return _internal_verbosity();
}
inline void SystemLoggerStatus::_internal_set_verbosity(::ActionModule::SystemLoggerStatus_Verbosity value) {
  
  verbosity_ = value;
}
inline void SystemLoggerStatus::set_verbosity(::ActionModule::SystemLoggerStatus_Verbosity value) {
  _internal_set_verbosity(value);
  // @@protoc_insertion_point(field_set:ActionModule.SystemLoggerStatus.verbosity)
}

// -------------------------------------------------------------------

// GreenButtonStatus

// bool isPressed = 1;
inline void GreenButtonStatus::clear_ispressed() {
  ispressed_ = false;
}
inline bool GreenButtonStatus::_internal_ispressed() const {
  return ispressed_;
}
inline bool GreenButtonStatus::ispressed() const {
  // @@protoc_insertion_point(field_get:ActionModule.GreenButtonStatus.isPressed)
  return _internal_ispressed();
}
inline void GreenButtonStatus::_internal_set_ispressed(bool value) {
  
  ispressed_ = value;
}
inline void GreenButtonStatus::set_ispressed(bool value) {
  _internal_set_ispressed(value);
  // @@protoc_insertion_point(field_set:ActionModule.GreenButtonStatus.isPressed)
}

// bool isAlive = 2;
inline void GreenButtonStatus::clear_isalive() {
  isalive_ = false;
}
inline bool GreenButtonStatus::_internal_isalive() const {
  return isalive_;
}
inline bool GreenButtonStatus::isalive() const {
  // @@protoc_insertion_point(field_get:ActionModule.GreenButtonStatus.isAlive)
  return _internal_isalive();
}
inline void GreenButtonStatus::_internal_set_isalive(bool value) {
  
  isalive_ = value;
}
inline void GreenButtonStatus::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:ActionModule.GreenButtonStatus.isAlive)
}

// -------------------------------------------------------------------

// RedButtonStatus

// bool isPressed = 1;
inline void RedButtonStatus::clear_ispressed() {
  ispressed_ = false;
}
inline bool RedButtonStatus::_internal_ispressed() const {
  return ispressed_;
}
inline bool RedButtonStatus::ispressed() const {
  // @@protoc_insertion_point(field_get:ActionModule.RedButtonStatus.isPressed)
  return _internal_ispressed();
}
inline void RedButtonStatus::_internal_set_ispressed(bool value) {
  
  ispressed_ = value;
}
inline void RedButtonStatus::set_ispressed(bool value) {
  _internal_set_ispressed(value);
  // @@protoc_insertion_point(field_set:ActionModule.RedButtonStatus.isPressed)
}

// -------------------------------------------------------------------

// WatchdogStatus

// bool isAlive = 1;
inline void WatchdogStatus::clear_isalive() {
  isalive_ = false;
}
inline bool WatchdogStatus::_internal_isalive() const {
  return isalive_;
}
inline bool WatchdogStatus::isalive() const {
  // @@protoc_insertion_point(field_get:ActionModule.WatchdogStatus.isAlive)
  return _internal_isalive();
}
inline void WatchdogStatus::_internal_set_isalive(bool value) {
  
  isalive_ = value;
}
inline void WatchdogStatus::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:ActionModule.WatchdogStatus.isAlive)
}

// string state = 2;
inline void WatchdogStatus::clear_state() {
  state_.ClearToEmpty();
}
inline const std::string& WatchdogStatus::state() const {
  // @@protoc_insertion_point(field_get:ActionModule.WatchdogStatus.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchdogStatus::set_state(ArgT0&& arg0, ArgT... args) {
 
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.WatchdogStatus.state)
}
inline std::string* WatchdogStatus::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:ActionModule.WatchdogStatus.state)
  return _s;
}
inline const std::string& WatchdogStatus::_internal_state() const {
  return state_.Get();
}
inline void WatchdogStatus::_internal_set_state(const std::string& value) {
  
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchdogStatus::_internal_mutable_state() {
  
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchdogStatus::release_state() {
  // @@protoc_insertion_point(field_release:ActionModule.WatchdogStatus.state)
  return state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchdogStatus::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.WatchdogStatus.state)
}

// -------------------------------------------------------------------

// SystemLoggerCommand

// .ActionModule.SystemLoggerCommand.Command command = 1;
inline void SystemLoggerCommand::clear_command() {
  command_ = 0;
}
inline ::ActionModule::SystemLoggerCommand_Command SystemLoggerCommand::_internal_command() const {
  return static_cast< ::ActionModule::SystemLoggerCommand_Command >(command_);
}
inline ::ActionModule::SystemLoggerCommand_Command SystemLoggerCommand::command() const {
  // @@protoc_insertion_point(field_get:ActionModule.SystemLoggerCommand.command)
  return _internal_command();
}
inline void SystemLoggerCommand::_internal_set_command(::ActionModule::SystemLoggerCommand_Command value) {
  
  command_ = value;
}
inline void SystemLoggerCommand::set_command(::ActionModule::SystemLoggerCommand_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:ActionModule.SystemLoggerCommand.command)
}

// -------------------------------------------------------------------

// GreenButtonCommand

// .ActionModule.GreenButtonCommand.Command command = 1;
inline void GreenButtonCommand::clear_command() {
  command_ = 0;
}
inline ::ActionModule::GreenButtonCommand_Command GreenButtonCommand::_internal_command() const {
  return static_cast< ::ActionModule::GreenButtonCommand_Command >(command_);
}
inline ::ActionModule::GreenButtonCommand_Command GreenButtonCommand::command() const {
  // @@protoc_insertion_point(field_get:ActionModule.GreenButtonCommand.command)
  return _internal_command();
}
inline void GreenButtonCommand::_internal_set_command(::ActionModule::GreenButtonCommand_Command value) {
  
  command_ = value;
}
inline void GreenButtonCommand::set_command(::ActionModule::GreenButtonCommand_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:ActionModule.GreenButtonCommand.command)
}

// -------------------------------------------------------------------

// RedButtonCommand

// .ActionModule.RedButtonCommand.Command command = 1;
inline void RedButtonCommand::clear_command() {
  command_ = 0;
}
inline ::ActionModule::RedButtonCommand_Command RedButtonCommand::_internal_command() const {
  return static_cast< ::ActionModule::RedButtonCommand_Command >(command_);
}
inline ::ActionModule::RedButtonCommand_Command RedButtonCommand::command() const {
  // @@protoc_insertion_point(field_get:ActionModule.RedButtonCommand.command)
  return _internal_command();
}
inline void RedButtonCommand::_internal_set_command(::ActionModule::RedButtonCommand_Command value) {
  
  command_ = value;
}
inline void RedButtonCommand::set_command(::ActionModule::RedButtonCommand_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:ActionModule.RedButtonCommand.command)
}

// -------------------------------------------------------------------

// WatchdogCommand

// .ActionModule.WatchdogCommand.Command command = 1;
inline void WatchdogCommand::clear_command() {
  command_ = 0;
}
inline ::ActionModule::WatchdogCommand_Command WatchdogCommand::_internal_command() const {
  return static_cast< ::ActionModule::WatchdogCommand_Command >(command_);
}
inline ::ActionModule::WatchdogCommand_Command WatchdogCommand::command() const {
  // @@protoc_insertion_point(field_get:ActionModule.WatchdogCommand.command)
  return _internal_command();
}
inline void WatchdogCommand::_internal_set_command(::ActionModule::WatchdogCommand_Command value) {
  
  command_ = value;
}
inline void WatchdogCommand::set_command(::ActionModule::WatchdogCommand_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:ActionModule.WatchdogCommand.command)
}

// -------------------------------------------------------------------

// SystemLoggerError

// string errorMessage = 1;
inline void SystemLoggerError::clear_errormessage() {
  errormessage_.ClearToEmpty();
}
inline const std::string& SystemLoggerError::errormessage() const {
  // @@protoc_insertion_point(field_get:ActionModule.SystemLoggerError.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemLoggerError::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.SystemLoggerError.errorMessage)
}
inline std::string* SystemLoggerError::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:ActionModule.SystemLoggerError.errorMessage)
  return _s;
}
inline const std::string& SystemLoggerError::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void SystemLoggerError::_internal_set_errormessage(const std::string& value) {
  
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemLoggerError::_internal_mutable_errormessage() {
  
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemLoggerError::release_errormessage() {
  // @@protoc_insertion_point(field_release:ActionModule.SystemLoggerError.errorMessage)
  return errormessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemLoggerError::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.SystemLoggerError.errorMessage)
}

// -------------------------------------------------------------------

// GreenButtonError

// string errorMessage = 1;
inline void GreenButtonError::clear_errormessage() {
  errormessage_.ClearToEmpty();
}
inline const std::string& GreenButtonError::errormessage() const {
  // @@protoc_insertion_point(field_get:ActionModule.GreenButtonError.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GreenButtonError::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.GreenButtonError.errorMessage)
}
inline std::string* GreenButtonError::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:ActionModule.GreenButtonError.errorMessage)
  return _s;
}
inline const std::string& GreenButtonError::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void GreenButtonError::_internal_set_errormessage(const std::string& value) {
  
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GreenButtonError::_internal_mutable_errormessage() {
  
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GreenButtonError::release_errormessage() {
  // @@protoc_insertion_point(field_release:ActionModule.GreenButtonError.errorMessage)
  return errormessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GreenButtonError::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.GreenButtonError.errorMessage)
}

// -------------------------------------------------------------------

// RedButtonError

// string errorMessage = 1;
inline void RedButtonError::clear_errormessage() {
  errormessage_.ClearToEmpty();
}
inline const std::string& RedButtonError::errormessage() const {
  // @@protoc_insertion_point(field_get:ActionModule.RedButtonError.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedButtonError::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.RedButtonError.errorMessage)
}
inline std::string* RedButtonError::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:ActionModule.RedButtonError.errorMessage)
  return _s;
}
inline const std::string& RedButtonError::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void RedButtonError::_internal_set_errormessage(const std::string& value) {
  
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RedButtonError::_internal_mutable_errormessage() {
  
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RedButtonError::release_errormessage() {
  // @@protoc_insertion_point(field_release:ActionModule.RedButtonError.errorMessage)
  return errormessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RedButtonError::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.RedButtonError.errorMessage)
}

// -------------------------------------------------------------------

// WatchdogError

// string errorMessage = 1;
inline void WatchdogError::clear_errormessage() {
  errormessage_.ClearToEmpty();
}
inline const std::string& WatchdogError::errormessage() const {
  // @@protoc_insertion_point(field_get:ActionModule.WatchdogError.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchdogError::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ActionModule.WatchdogError.errorMessage)
}
inline std::string* WatchdogError::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:ActionModule.WatchdogError.errorMessage)
  return _s;
}
inline const std::string& WatchdogError::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void WatchdogError::_internal_set_errormessage(const std::string& value) {
  
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchdogError::_internal_mutable_errormessage() {
  
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchdogError::release_errormessage() {
  // @@protoc_insertion_point(field_release:ActionModule.WatchdogError.errorMessage)
  return errormessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchdogError::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ActionModule.WatchdogError.errorMessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ActionModule

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ActionModule::ActionError_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::ActionError_Type>() {
  return ::ActionModule::ActionError_Type_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::Device_Module> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::Device_Module>() {
  return ::ActionModule::Device_Module_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::Device_DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::Device_DeviceType>() {
  return ::ActionModule::Device_DeviceType_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::SystemLoggerStatus_Verbosity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::SystemLoggerStatus_Verbosity>() {
  return ::ActionModule::SystemLoggerStatus_Verbosity_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::SystemLoggerCommand_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::SystemLoggerCommand_Command>() {
  return ::ActionModule::SystemLoggerCommand_Command_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::GreenButtonCommand_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::GreenButtonCommand_Command>() {
  return ::ActionModule::GreenButtonCommand_Command_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::RedButtonCommand_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::RedButtonCommand_Command>() {
  return ::ActionModule::RedButtonCommand_Command_descriptor();
}
template <> struct is_proto_enum< ::ActionModule::WatchdogCommand_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ActionModule::WatchdogCommand_Command>() {
  return ::ActionModule::WatchdogCommand_Command_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fActionModule_2eproto
