// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/CarAccessoryModule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fCarAccessoryModule_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fCarAccessoryModule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fCarAccessoryModule_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fCarAccessoryModule_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fCarAccessoryModule_2eproto;
namespace CarAccessoryModule {
class ButtonCommand;
struct ButtonCommandDefaultTypeInternal;
extern ButtonCommandDefaultTypeInternal _ButtonCommand_default_instance_;
class ButtonError;
struct ButtonErrorDefaultTypeInternal;
extern ButtonErrorDefaultTypeInternal _ButtonError_default_instance_;
class ButtonStatus;
struct ButtonStatusDefaultTypeInternal;
extern ButtonStatusDefaultTypeInternal _ButtonStatus_default_instance_;
class CarAccessoryCommand;
struct CarAccessoryCommandDefaultTypeInternal;
extern CarAccessoryCommandDefaultTypeInternal _CarAccessoryCommand_default_instance_;
class CarAccessoryError;
struct CarAccessoryErrorDefaultTypeInternal;
extern CarAccessoryErrorDefaultTypeInternal _CarAccessoryError_default_instance_;
class CarAccessoryStatus;
struct CarAccessoryStatusDefaultTypeInternal;
extern CarAccessoryStatusDefaultTypeInternal _CarAccessoryStatus_default_instance_;
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
}  // namespace CarAccessoryModule
PROTOBUF_NAMESPACE_OPEN
template<> ::CarAccessoryModule::ButtonCommand* Arena::CreateMaybeMessage<::CarAccessoryModule::ButtonCommand>(Arena*);
template<> ::CarAccessoryModule::ButtonError* Arena::CreateMaybeMessage<::CarAccessoryModule::ButtonError>(Arena*);
template<> ::CarAccessoryModule::ButtonStatus* Arena::CreateMaybeMessage<::CarAccessoryModule::ButtonStatus>(Arena*);
template<> ::CarAccessoryModule::CarAccessoryCommand* Arena::CreateMaybeMessage<::CarAccessoryModule::CarAccessoryCommand>(Arena*);
template<> ::CarAccessoryModule::CarAccessoryError* Arena::CreateMaybeMessage<::CarAccessoryModule::CarAccessoryError>(Arena*);
template<> ::CarAccessoryModule::CarAccessoryStatus* Arena::CreateMaybeMessage<::CarAccessoryModule::CarAccessoryStatus>(Arena*);
template<> ::CarAccessoryModule::Device* Arena::CreateMaybeMessage<::CarAccessoryModule::Device>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CarAccessoryModule {

enum Device_Module : int {
  Device_Module_RESERVED_MODULE = 0,
  Device_Module_CAR_ACCESSORY_MODULE = 2,
  Device_Module_Device_Module_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Device_Module_Device_Module_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Device_Module_IsValid(int value);
constexpr Device_Module Device_Module_Module_MIN = Device_Module_RESERVED_MODULE;
constexpr Device_Module Device_Module_Module_MAX = Device_Module_CAR_ACCESSORY_MODULE;
constexpr int Device_Module_Module_ARRAYSIZE = Device_Module_Module_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Device_Module_descriptor();
template<typename T>
inline const std::string& Device_Module_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Device_Module>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Device_Module_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Device_Module_descriptor(), enum_t_value);
}
inline bool Device_Module_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Device_Module* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Device_Module>(
    Device_Module_descriptor(), name, value);
}
enum Device_DeviceType : int {
  Device_DeviceType_BUTTON = 0,
  Device_DeviceType_Device_DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Device_DeviceType_Device_DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Device_DeviceType_IsValid(int value);
constexpr Device_DeviceType Device_DeviceType_DeviceType_MIN = Device_DeviceType_BUTTON;
constexpr Device_DeviceType Device_DeviceType_DeviceType_MAX = Device_DeviceType_BUTTON;
constexpr int Device_DeviceType_DeviceType_ARRAYSIZE = Device_DeviceType_DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Device_DeviceType_descriptor();
template<typename T>
inline const std::string& Device_DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Device_DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Device_DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Device_DeviceType_descriptor(), enum_t_value);
}
inline bool Device_DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Device_DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Device_DeviceType>(
    Device_DeviceType_descriptor(), name, value);
}
enum ButtonCommand_Command : int {
  ButtonCommand_Command_PRESS = 0,
  ButtonCommand_Command_ButtonCommand_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ButtonCommand_Command_ButtonCommand_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ButtonCommand_Command_IsValid(int value);
constexpr ButtonCommand_Command ButtonCommand_Command_Command_MIN = ButtonCommand_Command_PRESS;
constexpr ButtonCommand_Command ButtonCommand_Command_Command_MAX = ButtonCommand_Command_PRESS;
constexpr int ButtonCommand_Command_Command_ARRAYSIZE = ButtonCommand_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ButtonCommand_Command_descriptor();
template<typename T>
inline const std::string& ButtonCommand_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ButtonCommand_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ButtonCommand_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ButtonCommand_Command_descriptor(), enum_t_value);
}
inline bool ButtonCommand_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButtonCommand_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ButtonCommand_Command>(
    ButtonCommand_Command_descriptor(), name, value);
}
// ===================================================================

class CarAccessoryStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.CarAccessoryStatus) */ {
 public:
  inline CarAccessoryStatus() : CarAccessoryStatus(nullptr) {}
  ~CarAccessoryStatus() override;
  explicit constexpr CarAccessoryStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarAccessoryStatus(const CarAccessoryStatus& from);
  CarAccessoryStatus(CarAccessoryStatus&& from) noexcept
    : CarAccessoryStatus() {
    *this = ::std::move(from);
  }

  inline CarAccessoryStatus& operator=(const CarAccessoryStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarAccessoryStatus& operator=(CarAccessoryStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarAccessoryStatus& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceStatusTypeCase {
    kButtonStatus = 2,
    DEVICESTATUSTYPE_NOT_SET = 0,
  };

  static inline const CarAccessoryStatus* internal_default_instance() {
    return reinterpret_cast<const CarAccessoryStatus*>(
               &_CarAccessoryStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CarAccessoryStatus& a, CarAccessoryStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CarAccessoryStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarAccessoryStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarAccessoryStatus* New() const final {
    return new CarAccessoryStatus();
  }

  CarAccessoryStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarAccessoryStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarAccessoryStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CarAccessoryStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarAccessoryStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.CarAccessoryStatus";
  }
  protected:
  explicit CarAccessoryStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kButtonStatusFieldNumber = 2,
  };
  // .CarAccessoryModule.Device device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::CarAccessoryModule::Device& device() const;
  PROTOBUF_MUST_USE_RESULT ::CarAccessoryModule::Device* release_device();
  ::CarAccessoryModule::Device* mutable_device();
  void set_allocated_device(::CarAccessoryModule::Device* device);
  private:
  const ::CarAccessoryModule::Device& _internal_device() const;
  ::CarAccessoryModule::Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::CarAccessoryModule::Device* device);
  ::CarAccessoryModule::Device* unsafe_arena_release_device();

  // .CarAccessoryModule.ButtonStatus buttonStatus = 2;
  bool has_buttonstatus() const;
  private:
  bool _internal_has_buttonstatus() const;
  public:
  void clear_buttonstatus();
  const ::CarAccessoryModule::ButtonStatus& buttonstatus() const;
  PROTOBUF_MUST_USE_RESULT ::CarAccessoryModule::ButtonStatus* release_buttonstatus();
  ::CarAccessoryModule::ButtonStatus* mutable_buttonstatus();
  void set_allocated_buttonstatus(::CarAccessoryModule::ButtonStatus* buttonstatus);
  private:
  const ::CarAccessoryModule::ButtonStatus& _internal_buttonstatus() const;
  ::CarAccessoryModule::ButtonStatus* _internal_mutable_buttonstatus();
  public:
  void unsafe_arena_set_allocated_buttonstatus(
      ::CarAccessoryModule::ButtonStatus* buttonstatus);
  ::CarAccessoryModule::ButtonStatus* unsafe_arena_release_buttonstatus();

  void clear_DeviceStatusType();
  DeviceStatusTypeCase DeviceStatusType_case() const;
  // @@protoc_insertion_point(class_scope:CarAccessoryModule.CarAccessoryStatus)
 private:
  class _Internal;
  void set_has_buttonstatus();

  inline bool has_DeviceStatusType() const;
  inline void clear_has_DeviceStatusType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CarAccessoryModule::Device* device_;
  union DeviceStatusTypeUnion {
    constexpr DeviceStatusTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CarAccessoryModule::ButtonStatus* buttonstatus_;
  } DeviceStatusType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// -------------------------------------------------------------------

class CarAccessoryCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.CarAccessoryCommand) */ {
 public:
  inline CarAccessoryCommand() : CarAccessoryCommand(nullptr) {}
  ~CarAccessoryCommand() override;
  explicit constexpr CarAccessoryCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarAccessoryCommand(const CarAccessoryCommand& from);
  CarAccessoryCommand(CarAccessoryCommand&& from) noexcept
    : CarAccessoryCommand() {
    *this = ::std::move(from);
  }

  inline CarAccessoryCommand& operator=(const CarAccessoryCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarAccessoryCommand& operator=(CarAccessoryCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarAccessoryCommand& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceCommandTypeCase {
    kButtonCommand = 2,
    DEVICECOMMANDTYPE_NOT_SET = 0,
  };

  static inline const CarAccessoryCommand* internal_default_instance() {
    return reinterpret_cast<const CarAccessoryCommand*>(
               &_CarAccessoryCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CarAccessoryCommand& a, CarAccessoryCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(CarAccessoryCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarAccessoryCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarAccessoryCommand* New() const final {
    return new CarAccessoryCommand();
  }

  CarAccessoryCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarAccessoryCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarAccessoryCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CarAccessoryCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarAccessoryCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.CarAccessoryCommand";
  }
  protected:
  explicit CarAccessoryCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kButtonCommandFieldNumber = 2,
  };
  // .CarAccessoryModule.Device device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::CarAccessoryModule::Device& device() const;
  PROTOBUF_MUST_USE_RESULT ::CarAccessoryModule::Device* release_device();
  ::CarAccessoryModule::Device* mutable_device();
  void set_allocated_device(::CarAccessoryModule::Device* device);
  private:
  const ::CarAccessoryModule::Device& _internal_device() const;
  ::CarAccessoryModule::Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::CarAccessoryModule::Device* device);
  ::CarAccessoryModule::Device* unsafe_arena_release_device();

  // .CarAccessoryModule.ButtonCommand buttonCommand = 2;
  bool has_buttoncommand() const;
  private:
  bool _internal_has_buttoncommand() const;
  public:
  void clear_buttoncommand();
  const ::CarAccessoryModule::ButtonCommand& buttoncommand() const;
  PROTOBUF_MUST_USE_RESULT ::CarAccessoryModule::ButtonCommand* release_buttoncommand();
  ::CarAccessoryModule::ButtonCommand* mutable_buttoncommand();
  void set_allocated_buttoncommand(::CarAccessoryModule::ButtonCommand* buttoncommand);
  private:
  const ::CarAccessoryModule::ButtonCommand& _internal_buttoncommand() const;
  ::CarAccessoryModule::ButtonCommand* _internal_mutable_buttoncommand();
  public:
  void unsafe_arena_set_allocated_buttoncommand(
      ::CarAccessoryModule::ButtonCommand* buttoncommand);
  ::CarAccessoryModule::ButtonCommand* unsafe_arena_release_buttoncommand();

  void clear_DeviceCommandType();
  DeviceCommandTypeCase DeviceCommandType_case() const;
  // @@protoc_insertion_point(class_scope:CarAccessoryModule.CarAccessoryCommand)
 private:
  class _Internal;
  void set_has_buttoncommand();

  inline bool has_DeviceCommandType() const;
  inline void clear_has_DeviceCommandType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CarAccessoryModule::Device* device_;
  union DeviceCommandTypeUnion {
    constexpr DeviceCommandTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CarAccessoryModule::ButtonCommand* buttoncommand_;
  } DeviceCommandType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// -------------------------------------------------------------------

class CarAccessoryError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.CarAccessoryError) */ {
 public:
  inline CarAccessoryError() : CarAccessoryError(nullptr) {}
  ~CarAccessoryError() override;
  explicit constexpr CarAccessoryError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarAccessoryError(const CarAccessoryError& from);
  CarAccessoryError(CarAccessoryError&& from) noexcept
    : CarAccessoryError() {
    *this = ::std::move(from);
  }

  inline CarAccessoryError& operator=(const CarAccessoryError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarAccessoryError& operator=(CarAccessoryError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarAccessoryError& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceErrorTypeCase {
    kButtonError = 2,
    DEVICEERRORTYPE_NOT_SET = 0,
  };

  static inline const CarAccessoryError* internal_default_instance() {
    return reinterpret_cast<const CarAccessoryError*>(
               &_CarAccessoryError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CarAccessoryError& a, CarAccessoryError& b) {
    a.Swap(&b);
  }
  inline void Swap(CarAccessoryError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarAccessoryError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarAccessoryError* New() const final {
    return new CarAccessoryError();
  }

  CarAccessoryError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarAccessoryError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarAccessoryError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CarAccessoryError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarAccessoryError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.CarAccessoryError";
  }
  protected:
  explicit CarAccessoryError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kButtonErrorFieldNumber = 2,
  };
  // .CarAccessoryModule.Device device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::CarAccessoryModule::Device& device() const;
  PROTOBUF_MUST_USE_RESULT ::CarAccessoryModule::Device* release_device();
  ::CarAccessoryModule::Device* mutable_device();
  void set_allocated_device(::CarAccessoryModule::Device* device);
  private:
  const ::CarAccessoryModule::Device& _internal_device() const;
  ::CarAccessoryModule::Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::CarAccessoryModule::Device* device);
  ::CarAccessoryModule::Device* unsafe_arena_release_device();

  // .CarAccessoryModule.ButtonError buttonError = 2;
  bool has_buttonerror() const;
  private:
  bool _internal_has_buttonerror() const;
  public:
  void clear_buttonerror();
  const ::CarAccessoryModule::ButtonError& buttonerror() const;
  PROTOBUF_MUST_USE_RESULT ::CarAccessoryModule::ButtonError* release_buttonerror();
  ::CarAccessoryModule::ButtonError* mutable_buttonerror();
  void set_allocated_buttonerror(::CarAccessoryModule::ButtonError* buttonerror);
  private:
  const ::CarAccessoryModule::ButtonError& _internal_buttonerror() const;
  ::CarAccessoryModule::ButtonError* _internal_mutable_buttonerror();
  public:
  void unsafe_arena_set_allocated_buttonerror(
      ::CarAccessoryModule::ButtonError* buttonerror);
  ::CarAccessoryModule::ButtonError* unsafe_arena_release_buttonerror();

  void clear_DeviceErrorType();
  DeviceErrorTypeCase DeviceErrorType_case() const;
  // @@protoc_insertion_point(class_scope:CarAccessoryModule.CarAccessoryError)
 private:
  class _Internal;
  void set_has_buttonerror();

  inline bool has_DeviceErrorType() const;
  inline void clear_has_DeviceErrorType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CarAccessoryModule::Device* device_;
  union DeviceErrorTypeUnion {
    constexpr DeviceErrorTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CarAccessoryModule::ButtonError* buttonerror_;
  } DeviceErrorType_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// -------------------------------------------------------------------

class Device final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() override;
  explicit constexpr Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Device(const Device& from);
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Device* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Device* New() const final {
    return new Device();
  }

  Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Device& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Device& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Device* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.Device";
  }
  protected:
  explicit Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Device_Module Module;
  static constexpr Module RESERVED_MODULE =
    Device_Module_RESERVED_MODULE;
  static constexpr Module CAR_ACCESSORY_MODULE =
    Device_Module_CAR_ACCESSORY_MODULE;
  static inline bool Module_IsValid(int value) {
    return Device_Module_IsValid(value);
  }
  static constexpr Module Module_MIN =
    Device_Module_Module_MIN;
  static constexpr Module Module_MAX =
    Device_Module_Module_MAX;
  static constexpr int Module_ARRAYSIZE =
    Device_Module_Module_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Module_descriptor() {
    return Device_Module_descriptor();
  }
  template<typename T>
  static inline const std::string& Module_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Module>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Module_Name.");
    return Device_Module_Name(enum_t_value);
  }
  static inline bool Module_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Module* value) {
    return Device_Module_Parse(name, value);
  }

  typedef Device_DeviceType DeviceType;
  static constexpr DeviceType BUTTON =
    Device_DeviceType_BUTTON;
  static inline bool DeviceType_IsValid(int value) {
    return Device_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN =
    Device_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX =
    Device_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE =
    Device_DeviceType_DeviceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DeviceType_descriptor() {
    return Device_DeviceType_descriptor();
  }
  template<typename T>
  static inline const std::string& DeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeviceType_Name.");
    return Device_DeviceType_Name(enum_t_value);
  }
  static inline bool DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeviceType* value) {
    return Device_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceNameFieldNumber = 3,
    kModuleFieldNumber = 1,
    kDeviceTypeFieldNumber = 2,
  };
  // string deviceName = 3;
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_MUST_USE_RESULT std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // .CarAccessoryModule.Device.Module module = 1;
  void clear_module();
  ::CarAccessoryModule::Device_Module module() const;
  void set_module(::CarAccessoryModule::Device_Module value);
  private:
  ::CarAccessoryModule::Device_Module _internal_module() const;
  void _internal_set_module(::CarAccessoryModule::Device_Module value);
  public:

  // .CarAccessoryModule.Device.DeviceType deviceType = 2;
  void clear_devicetype();
  ::CarAccessoryModule::Device_DeviceType devicetype() const;
  void set_devicetype(::CarAccessoryModule::Device_DeviceType value);
  private:
  ::CarAccessoryModule::Device_DeviceType _internal_devicetype() const;
  void _internal_set_devicetype(::CarAccessoryModule::Device_DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:CarAccessoryModule.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
  int module_;
  int devicetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// -------------------------------------------------------------------

class ButtonStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.ButtonStatus) */ {
 public:
  inline ButtonStatus() : ButtonStatus(nullptr) {}
  ~ButtonStatus() override;
  explicit constexpr ButtonStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ButtonStatus(const ButtonStatus& from);
  ButtonStatus(ButtonStatus&& from) noexcept
    : ButtonStatus() {
    *this = ::std::move(from);
  }

  inline ButtonStatus& operator=(const ButtonStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonStatus& operator=(ButtonStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ButtonStatus* internal_default_instance() {
    return reinterpret_cast<const ButtonStatus*>(
               &_ButtonStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ButtonStatus& a, ButtonStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ButtonStatus* New() const final {
    return new ButtonStatus();
  }

  ButtonStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ButtonStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ButtonStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ButtonStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.ButtonStatus";
  }
  protected:
  explicit ButtonStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPressedFieldNumber = 1,
  };
  // bool isPressed = 1;
  void clear_ispressed();
  bool ispressed() const;
  void set_ispressed(bool value);
  private:
  bool _internal_ispressed() const;
  void _internal_set_ispressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CarAccessoryModule.ButtonStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ispressed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// -------------------------------------------------------------------

class ButtonCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.ButtonCommand) */ {
 public:
  inline ButtonCommand() : ButtonCommand(nullptr) {}
  ~ButtonCommand() override;
  explicit constexpr ButtonCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ButtonCommand(const ButtonCommand& from);
  ButtonCommand(ButtonCommand&& from) noexcept
    : ButtonCommand() {
    *this = ::std::move(from);
  }

  inline ButtonCommand& operator=(const ButtonCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonCommand& operator=(ButtonCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ButtonCommand* internal_default_instance() {
    return reinterpret_cast<const ButtonCommand*>(
               &_ButtonCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ButtonCommand& a, ButtonCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ButtonCommand* New() const final {
    return new ButtonCommand();
  }

  ButtonCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ButtonCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ButtonCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ButtonCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.ButtonCommand";
  }
  protected:
  explicit ButtonCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ButtonCommand_Command Command;
  static constexpr Command PRESS =
    ButtonCommand_Command_PRESS;
  static inline bool Command_IsValid(int value) {
    return ButtonCommand_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    ButtonCommand_Command_Command_MIN;
  static constexpr Command Command_MAX =
    ButtonCommand_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    ButtonCommand_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return ButtonCommand_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return ButtonCommand_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return ButtonCommand_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // .CarAccessoryModule.ButtonCommand.Command command = 1;
  void clear_command();
  ::CarAccessoryModule::ButtonCommand_Command command() const;
  void set_command(::CarAccessoryModule::ButtonCommand_Command value);
  private:
  ::CarAccessoryModule::ButtonCommand_Command _internal_command() const;
  void _internal_set_command(::CarAccessoryModule::ButtonCommand_Command value);
  public:

  // @@protoc_insertion_point(class_scope:CarAccessoryModule.ButtonCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// -------------------------------------------------------------------

class ButtonError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CarAccessoryModule.ButtonError) */ {
 public:
  inline ButtonError() : ButtonError(nullptr) {}
  ~ButtonError() override;
  explicit constexpr ButtonError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ButtonError(const ButtonError& from);
  ButtonError(ButtonError&& from) noexcept
    : ButtonError() {
    *this = ::std::move(from);
  }

  inline ButtonError& operator=(const ButtonError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonError& operator=(ButtonError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ButtonError& default_instance() {
    return *internal_default_instance();
  }
  static inline const ButtonError* internal_default_instance() {
    return reinterpret_cast<const ButtonError*>(
               &_ButtonError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ButtonError& a, ButtonError& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ButtonError* New() const final {
    return new ButtonError();
  }

  ButtonError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ButtonError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ButtonError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ButtonError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CarAccessoryModule.ButtonError";
  }
  protected:
  explicit ButtonError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPressCountFieldNumber = 1,
  };
  // uint32 pressCount = 1;
  void clear_presscount();
  ::PROTOBUF_NAMESPACE_ID::uint32 presscount() const;
  void set_presscount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_presscount() const;
  void _internal_set_presscount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:CarAccessoryModule.ButtonError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 presscount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fCarAccessoryModule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CarAccessoryStatus

// .CarAccessoryModule.Device device = 1;
inline bool CarAccessoryStatus::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool CarAccessoryStatus::has_device() const {
  return _internal_has_device();
}
inline void CarAccessoryStatus::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::CarAccessoryModule::Device& CarAccessoryStatus::_internal_device() const {
  const ::CarAccessoryModule::Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::CarAccessoryModule::Device&>(
      ::CarAccessoryModule::_Device_default_instance_);
}
inline const ::CarAccessoryModule::Device& CarAccessoryStatus::device() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.CarAccessoryStatus.device)
  return _internal_device();
}
inline void CarAccessoryStatus::unsafe_arena_set_allocated_device(
    ::CarAccessoryModule::Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarAccessoryModule.CarAccessoryStatus.device)
}
inline ::CarAccessoryModule::Device* CarAccessoryStatus::release_device() {
  
  ::CarAccessoryModule::Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CarAccessoryModule::Device* CarAccessoryStatus::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.CarAccessoryStatus.device)
  
  ::CarAccessoryModule::Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::CarAccessoryModule::Device* CarAccessoryStatus::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::CarAccessoryModule::Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::CarAccessoryModule::Device* CarAccessoryStatus::mutable_device() {
  ::CarAccessoryModule::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.CarAccessoryStatus.device)
  return _msg;
}
inline void CarAccessoryStatus::set_allocated_device(::CarAccessoryModule::Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CarAccessoryModule::Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:CarAccessoryModule.CarAccessoryStatus.device)
}

// .CarAccessoryModule.ButtonStatus buttonStatus = 2;
inline bool CarAccessoryStatus::_internal_has_buttonstatus() const {
  return DeviceStatusType_case() == kButtonStatus;
}
inline bool CarAccessoryStatus::has_buttonstatus() const {
  return _internal_has_buttonstatus();
}
inline void CarAccessoryStatus::set_has_buttonstatus() {
  _oneof_case_[0] = kButtonStatus;
}
inline void CarAccessoryStatus::clear_buttonstatus() {
  if (_internal_has_buttonstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceStatusType_.buttonstatus_;
    }
    clear_has_DeviceStatusType();
  }
}
inline ::CarAccessoryModule::ButtonStatus* CarAccessoryStatus::release_buttonstatus() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.CarAccessoryStatus.buttonStatus)
  if (_internal_has_buttonstatus()) {
    clear_has_DeviceStatusType();
      ::CarAccessoryModule::ButtonStatus* temp = DeviceStatusType_.buttonstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceStatusType_.buttonstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CarAccessoryModule::ButtonStatus& CarAccessoryStatus::_internal_buttonstatus() const {
  return _internal_has_buttonstatus()
      ? *DeviceStatusType_.buttonstatus_
      : reinterpret_cast< ::CarAccessoryModule::ButtonStatus&>(::CarAccessoryModule::_ButtonStatus_default_instance_);
}
inline const ::CarAccessoryModule::ButtonStatus& CarAccessoryStatus::buttonstatus() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.CarAccessoryStatus.buttonStatus)
  return _internal_buttonstatus();
}
inline ::CarAccessoryModule::ButtonStatus* CarAccessoryStatus::unsafe_arena_release_buttonstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CarAccessoryModule.CarAccessoryStatus.buttonStatus)
  if (_internal_has_buttonstatus()) {
    clear_has_DeviceStatusType();
    ::CarAccessoryModule::ButtonStatus* temp = DeviceStatusType_.buttonstatus_;
    DeviceStatusType_.buttonstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CarAccessoryStatus::unsafe_arena_set_allocated_buttonstatus(::CarAccessoryModule::ButtonStatus* buttonstatus) {
  clear_DeviceStatusType();
  if (buttonstatus) {
    set_has_buttonstatus();
    DeviceStatusType_.buttonstatus_ = buttonstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarAccessoryModule.CarAccessoryStatus.buttonStatus)
}
inline ::CarAccessoryModule::ButtonStatus* CarAccessoryStatus::_internal_mutable_buttonstatus() {
  if (!_internal_has_buttonstatus()) {
    clear_DeviceStatusType();
    set_has_buttonstatus();
    DeviceStatusType_.buttonstatus_ = CreateMaybeMessage< ::CarAccessoryModule::ButtonStatus >(GetArenaForAllocation());
  }
  return DeviceStatusType_.buttonstatus_;
}
inline ::CarAccessoryModule::ButtonStatus* CarAccessoryStatus::mutable_buttonstatus() {
  ::CarAccessoryModule::ButtonStatus* _msg = _internal_mutable_buttonstatus();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.CarAccessoryStatus.buttonStatus)
  return _msg;
}

inline bool CarAccessoryStatus::has_DeviceStatusType() const {
  return DeviceStatusType_case() != DEVICESTATUSTYPE_NOT_SET;
}
inline void CarAccessoryStatus::clear_has_DeviceStatusType() {
  _oneof_case_[0] = DEVICESTATUSTYPE_NOT_SET;
}
inline CarAccessoryStatus::DeviceStatusTypeCase CarAccessoryStatus::DeviceStatusType_case() const {
  return CarAccessoryStatus::DeviceStatusTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CarAccessoryCommand

// .CarAccessoryModule.Device device = 1;
inline bool CarAccessoryCommand::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool CarAccessoryCommand::has_device() const {
  return _internal_has_device();
}
inline void CarAccessoryCommand::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::CarAccessoryModule::Device& CarAccessoryCommand::_internal_device() const {
  const ::CarAccessoryModule::Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::CarAccessoryModule::Device&>(
      ::CarAccessoryModule::_Device_default_instance_);
}
inline const ::CarAccessoryModule::Device& CarAccessoryCommand::device() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.CarAccessoryCommand.device)
  return _internal_device();
}
inline void CarAccessoryCommand::unsafe_arena_set_allocated_device(
    ::CarAccessoryModule::Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarAccessoryModule.CarAccessoryCommand.device)
}
inline ::CarAccessoryModule::Device* CarAccessoryCommand::release_device() {
  
  ::CarAccessoryModule::Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CarAccessoryModule::Device* CarAccessoryCommand::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.CarAccessoryCommand.device)
  
  ::CarAccessoryModule::Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::CarAccessoryModule::Device* CarAccessoryCommand::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::CarAccessoryModule::Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::CarAccessoryModule::Device* CarAccessoryCommand::mutable_device() {
  ::CarAccessoryModule::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.CarAccessoryCommand.device)
  return _msg;
}
inline void CarAccessoryCommand::set_allocated_device(::CarAccessoryModule::Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CarAccessoryModule::Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:CarAccessoryModule.CarAccessoryCommand.device)
}

// .CarAccessoryModule.ButtonCommand buttonCommand = 2;
inline bool CarAccessoryCommand::_internal_has_buttoncommand() const {
  return DeviceCommandType_case() == kButtonCommand;
}
inline bool CarAccessoryCommand::has_buttoncommand() const {
  return _internal_has_buttoncommand();
}
inline void CarAccessoryCommand::set_has_buttoncommand() {
  _oneof_case_[0] = kButtonCommand;
}
inline void CarAccessoryCommand::clear_buttoncommand() {
  if (_internal_has_buttoncommand()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceCommandType_.buttoncommand_;
    }
    clear_has_DeviceCommandType();
  }
}
inline ::CarAccessoryModule::ButtonCommand* CarAccessoryCommand::release_buttoncommand() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.CarAccessoryCommand.buttonCommand)
  if (_internal_has_buttoncommand()) {
    clear_has_DeviceCommandType();
      ::CarAccessoryModule::ButtonCommand* temp = DeviceCommandType_.buttoncommand_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceCommandType_.buttoncommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CarAccessoryModule::ButtonCommand& CarAccessoryCommand::_internal_buttoncommand() const {
  return _internal_has_buttoncommand()
      ? *DeviceCommandType_.buttoncommand_
      : reinterpret_cast< ::CarAccessoryModule::ButtonCommand&>(::CarAccessoryModule::_ButtonCommand_default_instance_);
}
inline const ::CarAccessoryModule::ButtonCommand& CarAccessoryCommand::buttoncommand() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.CarAccessoryCommand.buttonCommand)
  return _internal_buttoncommand();
}
inline ::CarAccessoryModule::ButtonCommand* CarAccessoryCommand::unsafe_arena_release_buttoncommand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CarAccessoryModule.CarAccessoryCommand.buttonCommand)
  if (_internal_has_buttoncommand()) {
    clear_has_DeviceCommandType();
    ::CarAccessoryModule::ButtonCommand* temp = DeviceCommandType_.buttoncommand_;
    DeviceCommandType_.buttoncommand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CarAccessoryCommand::unsafe_arena_set_allocated_buttoncommand(::CarAccessoryModule::ButtonCommand* buttoncommand) {
  clear_DeviceCommandType();
  if (buttoncommand) {
    set_has_buttoncommand();
    DeviceCommandType_.buttoncommand_ = buttoncommand;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarAccessoryModule.CarAccessoryCommand.buttonCommand)
}
inline ::CarAccessoryModule::ButtonCommand* CarAccessoryCommand::_internal_mutable_buttoncommand() {
  if (!_internal_has_buttoncommand()) {
    clear_DeviceCommandType();
    set_has_buttoncommand();
    DeviceCommandType_.buttoncommand_ = CreateMaybeMessage< ::CarAccessoryModule::ButtonCommand >(GetArenaForAllocation());
  }
  return DeviceCommandType_.buttoncommand_;
}
inline ::CarAccessoryModule::ButtonCommand* CarAccessoryCommand::mutable_buttoncommand() {
  ::CarAccessoryModule::ButtonCommand* _msg = _internal_mutable_buttoncommand();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.CarAccessoryCommand.buttonCommand)
  return _msg;
}

inline bool CarAccessoryCommand::has_DeviceCommandType() const {
  return DeviceCommandType_case() != DEVICECOMMANDTYPE_NOT_SET;
}
inline void CarAccessoryCommand::clear_has_DeviceCommandType() {
  _oneof_case_[0] = DEVICECOMMANDTYPE_NOT_SET;
}
inline CarAccessoryCommand::DeviceCommandTypeCase CarAccessoryCommand::DeviceCommandType_case() const {
  return CarAccessoryCommand::DeviceCommandTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CarAccessoryError

// .CarAccessoryModule.Device device = 1;
inline bool CarAccessoryError::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool CarAccessoryError::has_device() const {
  return _internal_has_device();
}
inline void CarAccessoryError::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::CarAccessoryModule::Device& CarAccessoryError::_internal_device() const {
  const ::CarAccessoryModule::Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::CarAccessoryModule::Device&>(
      ::CarAccessoryModule::_Device_default_instance_);
}
inline const ::CarAccessoryModule::Device& CarAccessoryError::device() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.CarAccessoryError.device)
  return _internal_device();
}
inline void CarAccessoryError::unsafe_arena_set_allocated_device(
    ::CarAccessoryModule::Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarAccessoryModule.CarAccessoryError.device)
}
inline ::CarAccessoryModule::Device* CarAccessoryError::release_device() {
  
  ::CarAccessoryModule::Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CarAccessoryModule::Device* CarAccessoryError::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.CarAccessoryError.device)
  
  ::CarAccessoryModule::Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::CarAccessoryModule::Device* CarAccessoryError::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::CarAccessoryModule::Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::CarAccessoryModule::Device* CarAccessoryError::mutable_device() {
  ::CarAccessoryModule::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.CarAccessoryError.device)
  return _msg;
}
inline void CarAccessoryError::set_allocated_device(::CarAccessoryModule::Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CarAccessoryModule::Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:CarAccessoryModule.CarAccessoryError.device)
}

// .CarAccessoryModule.ButtonError buttonError = 2;
inline bool CarAccessoryError::_internal_has_buttonerror() const {
  return DeviceErrorType_case() == kButtonError;
}
inline bool CarAccessoryError::has_buttonerror() const {
  return _internal_has_buttonerror();
}
inline void CarAccessoryError::set_has_buttonerror() {
  _oneof_case_[0] = kButtonError;
}
inline void CarAccessoryError::clear_buttonerror() {
  if (_internal_has_buttonerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete DeviceErrorType_.buttonerror_;
    }
    clear_has_DeviceErrorType();
  }
}
inline ::CarAccessoryModule::ButtonError* CarAccessoryError::release_buttonerror() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.CarAccessoryError.buttonError)
  if (_internal_has_buttonerror()) {
    clear_has_DeviceErrorType();
      ::CarAccessoryModule::ButtonError* temp = DeviceErrorType_.buttonerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    DeviceErrorType_.buttonerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CarAccessoryModule::ButtonError& CarAccessoryError::_internal_buttonerror() const {
  return _internal_has_buttonerror()
      ? *DeviceErrorType_.buttonerror_
      : reinterpret_cast< ::CarAccessoryModule::ButtonError&>(::CarAccessoryModule::_ButtonError_default_instance_);
}
inline const ::CarAccessoryModule::ButtonError& CarAccessoryError::buttonerror() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.CarAccessoryError.buttonError)
  return _internal_buttonerror();
}
inline ::CarAccessoryModule::ButtonError* CarAccessoryError::unsafe_arena_release_buttonerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CarAccessoryModule.CarAccessoryError.buttonError)
  if (_internal_has_buttonerror()) {
    clear_has_DeviceErrorType();
    ::CarAccessoryModule::ButtonError* temp = DeviceErrorType_.buttonerror_;
    DeviceErrorType_.buttonerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CarAccessoryError::unsafe_arena_set_allocated_buttonerror(::CarAccessoryModule::ButtonError* buttonerror) {
  clear_DeviceErrorType();
  if (buttonerror) {
    set_has_buttonerror();
    DeviceErrorType_.buttonerror_ = buttonerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CarAccessoryModule.CarAccessoryError.buttonError)
}
inline ::CarAccessoryModule::ButtonError* CarAccessoryError::_internal_mutable_buttonerror() {
  if (!_internal_has_buttonerror()) {
    clear_DeviceErrorType();
    set_has_buttonerror();
    DeviceErrorType_.buttonerror_ = CreateMaybeMessage< ::CarAccessoryModule::ButtonError >(GetArenaForAllocation());
  }
  return DeviceErrorType_.buttonerror_;
}
inline ::CarAccessoryModule::ButtonError* CarAccessoryError::mutable_buttonerror() {
  ::CarAccessoryModule::ButtonError* _msg = _internal_mutable_buttonerror();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.CarAccessoryError.buttonError)
  return _msg;
}

inline bool CarAccessoryError::has_DeviceErrorType() const {
  return DeviceErrorType_case() != DEVICEERRORTYPE_NOT_SET;
}
inline void CarAccessoryError::clear_has_DeviceErrorType() {
  _oneof_case_[0] = DEVICEERRORTYPE_NOT_SET;
}
inline CarAccessoryError::DeviceErrorTypeCase CarAccessoryError::DeviceErrorType_case() const {
  return CarAccessoryError::DeviceErrorTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Device

// .CarAccessoryModule.Device.Module module = 1;
inline void Device::clear_module() {
  module_ = 0;
}
inline ::CarAccessoryModule::Device_Module Device::_internal_module() const {
  return static_cast< ::CarAccessoryModule::Device_Module >(module_);
}
inline ::CarAccessoryModule::Device_Module Device::module() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.Device.module)
  return _internal_module();
}
inline void Device::_internal_set_module(::CarAccessoryModule::Device_Module value) {
  
  module_ = value;
}
inline void Device::set_module(::CarAccessoryModule::Device_Module value) {
  _internal_set_module(value);
  // @@protoc_insertion_point(field_set:CarAccessoryModule.Device.module)
}

// .CarAccessoryModule.Device.DeviceType deviceType = 2;
inline void Device::clear_devicetype() {
  devicetype_ = 0;
}
inline ::CarAccessoryModule::Device_DeviceType Device::_internal_devicetype() const {
  return static_cast< ::CarAccessoryModule::Device_DeviceType >(devicetype_);
}
inline ::CarAccessoryModule::Device_DeviceType Device::devicetype() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.Device.deviceType)
  return _internal_devicetype();
}
inline void Device::_internal_set_devicetype(::CarAccessoryModule::Device_DeviceType value) {
  
  devicetype_ = value;
}
inline void Device::set_devicetype(::CarAccessoryModule::Device_DeviceType value) {
  _internal_set_devicetype(value);
  // @@protoc_insertion_point(field_set:CarAccessoryModule.Device.deviceType)
}

// string deviceName = 3;
inline void Device::clear_devicename() {
  devicename_.ClearToEmpty();
}
inline const std::string& Device::devicename() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.Device.deviceName)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_devicename(ArgT0&& arg0, ArgT... args) {
 
 devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CarAccessoryModule.Device.deviceName)
}
inline std::string* Device::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:CarAccessoryModule.Device.deviceName)
  return _s;
}
inline const std::string& Device::_internal_devicename() const {
  return devicename_.Get();
}
inline void Device::_internal_set_devicename(const std::string& value) {
  
  devicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_devicename() {
  
  return devicename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_devicename() {
  // @@protoc_insertion_point(field_release:CarAccessoryModule.Device.deviceName)
  return devicename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    
  } else {
    
  }
  devicename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devicename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CarAccessoryModule.Device.deviceName)
}

// -------------------------------------------------------------------

// ButtonStatus

// bool isPressed = 1;
inline void ButtonStatus::clear_ispressed() {
  ispressed_ = false;
}
inline bool ButtonStatus::_internal_ispressed() const {
  return ispressed_;
}
inline bool ButtonStatus::ispressed() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.ButtonStatus.isPressed)
  return _internal_ispressed();
}
inline void ButtonStatus::_internal_set_ispressed(bool value) {
  
  ispressed_ = value;
}
inline void ButtonStatus::set_ispressed(bool value) {
  _internal_set_ispressed(value);
  // @@protoc_insertion_point(field_set:CarAccessoryModule.ButtonStatus.isPressed)
}

// -------------------------------------------------------------------

// ButtonCommand

// .CarAccessoryModule.ButtonCommand.Command command = 1;
inline void ButtonCommand::clear_command() {
  command_ = 0;
}
inline ::CarAccessoryModule::ButtonCommand_Command ButtonCommand::_internal_command() const {
  return static_cast< ::CarAccessoryModule::ButtonCommand_Command >(command_);
}
inline ::CarAccessoryModule::ButtonCommand_Command ButtonCommand::command() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.ButtonCommand.command)
  return _internal_command();
}
inline void ButtonCommand::_internal_set_command(::CarAccessoryModule::ButtonCommand_Command value) {
  
  command_ = value;
}
inline void ButtonCommand::set_command(::CarAccessoryModule::ButtonCommand_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:CarAccessoryModule.ButtonCommand.command)
}

// -------------------------------------------------------------------

// ButtonError

// uint32 pressCount = 1;
inline void ButtonError::clear_presscount() {
  presscount_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ButtonError::_internal_presscount() const {
  return presscount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ButtonError::presscount() const {
  // @@protoc_insertion_point(field_get:CarAccessoryModule.ButtonError.pressCount)
  return _internal_presscount();
}
inline void ButtonError::_internal_set_presscount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  presscount_ = value;
}
inline void ButtonError::set_presscount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_presscount(value);
  // @@protoc_insertion_point(field_set:CarAccessoryModule.ButtonError.pressCount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CarAccessoryModule

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CarAccessoryModule::Device_Module> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarAccessoryModule::Device_Module>() {
  return ::CarAccessoryModule::Device_Module_descriptor();
}
template <> struct is_proto_enum< ::CarAccessoryModule::Device_DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarAccessoryModule::Device_DeviceType>() {
  return ::CarAccessoryModule::Device_DeviceType_descriptor();
}
template <> struct is_proto_enum< ::CarAccessoryModule::ButtonCommand_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CarAccessoryModule::ButtonCommand_Command>() {
  return ::CarAccessoryModule::ButtonCommand_Command_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fCarAccessoryModule_2eproto
